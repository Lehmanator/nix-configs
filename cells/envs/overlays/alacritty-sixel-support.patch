From 08ceb315108895390792459943fef4069124494f Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Wed, 10 Mar 2021 20:21:36 +0000
Subject: [PATCH 01/29] Add Sixel support
Repo: https://github.com/alacritty/alacritty/pull/4763

Fixes #910
---
 CHANGELOG.md                                  |   1 +
 Cargo.lock                                    |  10 +
 alacritty/Cargo.toml                          |   1 +
 alacritty/res/graphics.f.glsl                 |  40 +
 alacritty/res/graphics.v.glsl                 |  79 ++
 alacritty/src/display/content.rs              |   3 +
 alacritty/src/display/mod.rs                  |  14 +-
 alacritty/src/renderer/graphics/draw.rs       | 242 ++++++
 alacritty/src/renderer/graphics/mod.rs        | 149 ++++
 alacritty/src/renderer/graphics/shader.rs     | 199 +++++
 alacritty/src/renderer/mod.rs                 |  19 +
 alacritty/src/url.rs                          |   1 +
 alacritty_terminal/src/ansi.rs                |  40 +-
 alacritty_terminal/src/graphics/mod.rs        | 146 ++++
 alacritty_terminal/src/graphics/sixel.rs      | 772 ++++++++++++++++++
 alacritty_terminal/src/lib.rs                 |   1 +
 alacritty_terminal/src/term/cell.rs           |  23 +-
 alacritty_terminal/src/term/mod.rs            | 111 ++-
 alacritty_terminal/tests/sixel/README.md      |  50 ++
 .../tests/sixel/testimage_im6.rgba            | Bin 0 -> 16384 bytes
 .../tests/sixel/testimage_im6.sixel           |   1 +
 .../tests/sixel/testimage_libsixel.rgba       | Bin 0 -> 16384 bytes
 .../tests/sixel/testimage_libsixel.sixel      |   1 +
 .../tests/sixel/testimage_ppmtosixel.rgba     | Bin 0 -> 16384 bytes
 .../tests/sixel/testimage_ppmtosixel.sixel    |  77 ++
 docs/escape_support.md                        |   1 +
 docs/features.md                              |   5 +
 27 files changed, 1981 insertions(+), 5 deletions(-)
 create mode 100644 alacritty/res/graphics.f.glsl
 create mode 100644 alacritty/res/graphics.v.glsl
 create mode 100644 alacritty/src/renderer/graphics/draw.rs
 create mode 100644 alacritty/src/renderer/graphics/mod.rs
 create mode 100644 alacritty/src/renderer/graphics/shader.rs
 create mode 100644 alacritty_terminal/src/graphics/mod.rs
 create mode 100644 alacritty_terminal/src/graphics/sixel.rs
 create mode 100644 alacritty_terminal/tests/sixel/README.md
 create mode 100644 alacritty_terminal/tests/sixel/testimage_im6.rgba
 create mode 100644 alacritty_terminal/tests/sixel/testimage_im6.sixel
 create mode 100644 alacritty_terminal/tests/sixel/testimage_libsixel.rgba
 create mode 100644 alacritty_terminal/tests/sixel/testimage_libsixel.sixel
 create mode 100644 alacritty_terminal/tests/sixel/testimage_ppmtosixel.rgba
 create mode 100644 alacritty_terminal/tests/sixel/testimage_ppmtosixel.sixel

diff --git a/CHANGELOG.md b/CHANGELOG.md
index 9fbe458b6d..59478697c1 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -16,6 +16,7 @@ The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).
 - IME composition preview not appearing on Windows
 - Synchronized terminal updates using `DCS = 1 s ST`/`DCS = 2 s ST`
 - Regex terminal hints ([see features.md](./docs/features.md#hints))
+- Support for Sixel protocol

 ### Fixed

diff --git a/Cargo.lock b/Cargo.lock
index 505b64d207..3f220b08a5 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -30,6 +30,7 @@ dependencies = [
  "glutin",
  "libc",
  "log",
+ "memoffset",
  "notify",
  "objc",
  "parking_lot",
@@ -984,6 +985,15 @@ dependencies = [
  "libc",
 ]

+[[package]]
+name = "memoffset"
+version = "0.6.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "157b4208e3059a8f9e78d559edc658e13df41410cb3ae03979c83130067fdd87"
+dependencies = [
+ "autocfg",
+]
+
 [[package]]
 name = "miniz_oxide"
 version = "0.3.7"
diff --git a/alacritty/Cargo.toml b/alacritty/Cargo.toml
index febfbdc78b..5f0c06aefe 100644
--- a/alacritty/Cargo.toml
+++ b/alacritty/Cargo.toml
@@ -35,6 +35,7 @@ libc = "0.2"
 unicode-width = "0.1"
 bitflags = "1"
 dirs = "3.0.1"
+memoffset = "0.6.1"

 [build-dependencies]
 gl_generator = "0.14.0"
diff --git a/alacritty/res/graphics.f.glsl b/alacritty/res/graphics.f.glsl
new file mode 100644
index 0000000000..28da2a6844
--- /dev/null
+++ b/alacritty/res/graphics.f.glsl
@@ -0,0 +1,40 @@
+#version 330 core
+
+// Index in the textures[] uniform.
+flat in int texId;
+
+// Texture coordinates.
+in vec2 texCoords;
+
+// Array with graphics data.
+uniform sampler2D textures[16];
+
+// Computed color.
+out vec4 color;
+
+void main() {
+    // The expression `textures[texId]` can't be used in OpenGL 3.3.
+    // If we try to use it, the compiler throws this error:
+    //
+    //     sampler arrays indexed with non-constant expressions
+    //     are forbidden in GLSL 1.30 and later
+    //
+    // To overcome this limitation we use a switch for every valid
+    // value of `texId`.
+    //
+    // The first expression (`textures[texId]`) works with OpenGL 4.0
+    // or later (using `#version 400 core`). If Alacritty drops support
+    // for OpenGL 3.3, this switch block can be replaced with it.
+
+
+#define TEX(N) case N: color = texture(textures[N], texCoords); break;
+
+    switch(texId) {
+        TEX( 0) TEX( 1) TEX( 2) TEX( 3)
+        TEX( 4) TEX( 5) TEX( 6) TEX( 7)
+        TEX( 8) TEX( 9) TEX(10) TEX(11)
+        TEX(12) TEX(13) TEX(14) TEX(15)
+        default:
+            discard;
+    }
+}
diff --git a/alacritty/res/graphics.v.glsl b/alacritty/res/graphics.v.glsl
new file mode 100644
index 0000000000..56998e9dea
--- /dev/null
+++ b/alacritty/res/graphics.v.glsl
@@ -0,0 +1,79 @@
+#version 330 core
+
+// ------
+// INPUTS
+
+// Texture associated to the graphic.
+layout(location = 0) in int textureId;
+
+// Sides where the vertex is located.
+//
+// Bit 0 (LSB) is 0 for top and 1 for bottom.
+// Bit 1 is 0 for left and 1 for right.
+layout(location = 1) in int sides;
+
+// Column number in the grid where the left vertex is set.
+layout(location = 2) in float column;
+
+// Line number in the grid where the left vertex is set.
+layout(location = 3) in float line;
+
+// Height in pixels of the texture.
+layout(location = 4) in float height;
+
+// Width in pixels of the texture.
+layout(location = 5) in float width;
+
+// Offset in the X direction.
+layout(location = 6) in float offsetX;
+
+// Offset in the Y direction.
+layout(location = 7) in float offsetY;
+
+// Height in pixels of a single cell when the graphic was added.
+layout(location = 8) in float baseCellHeight;
+
+// -------
+// OUTPUTS
+
+// Texture sent to the fragment shader.
+flat out int texId;
+
+// Coordinates sent to the fragment shader.
+out vec2 texCoords;
+
+// --------
+// UNIFORMS
+
+// Width and height of a single cell.
+uniform vec2 cellDimensions;
+
+// Width and height of the view.
+uniform vec2 viewDimensions;
+
+
+#define IS_RIGHT_SIDE ((sides & 1) == 1)
+#define IS_BOTTOM_SIDE ((sides & 2) == 2)
+
+void main() {
+    float scale = cellDimensions.y / baseCellHeight;
+    float x = (column * cellDimensions.x - offsetX * scale) / (viewDimensions.x / 2) - 1;
+    float y = -(line * cellDimensions.y - offsetY * scale) / (viewDimensions.y / 2) + 1;
+
+    vec4 position = vec4(x, y, 0, 1);
+    vec2 coords = vec2(0, 0);
+
+    if(IS_RIGHT_SIDE) {
+        position.x += scale * width / (viewDimensions.x / 2);
+        coords.x = 1;
+    }
+
+    if(IS_BOTTOM_SIDE) {
+        position.y += -scale * height / (viewDimensions.y / 2);
+        coords.y = 1;
+    }
+
+    gl_Position = position;
+    texCoords = coords;
+    texId = textureId;
+}
diff --git a/alacritty/src/display/content.rs b/alacritty/src/display/content.rs
index a25ddce8fc..aa63836c98 100644
--- a/alacritty/src/display/content.rs
+++ b/alacritty/src/display/content.rs
@@ -6,6 +6,7 @@ use std::ops::{Deref, DerefMut, RangeInclusive};
 use alacritty_terminal::ansi::{Color, CursorShape, NamedColor};
 use alacritty_terminal::config::Config;
 use alacritty_terminal::event::EventListener;
+use alacritty_terminal::graphics::GraphicCell;
 use alacritty_terminal::grid::{Dimensions, Indexed};
 use alacritty_terminal::index::{Column, Direction, Line, Point};
 use alacritty_terminal::term::cell::{Cell, Flags};
@@ -178,6 +179,7 @@ impl<'a> Iterator for RenderableContent<'a> {
 pub struct RenderableCell {
     pub character: char,
     pub zerowidth: Option<Vec<char>>,
+    pub graphic: Option<GraphicCell>,
     pub point: Point,
     pub fg: Rgb,
     pub bg: Rgb,
@@ -240,6 +242,7 @@ impl RenderableCell {
         RenderableCell {
             character,
             zerowidth: cell.zerowidth().map(|zerowidth| zerowidth.to_vec()),
+            graphic: cell.graphic().cloned(),
             point: cell.point,
             fg: fg_rgb,
             bg: bg_rgb,
diff --git a/alacritty/src/display/mod.rs b/alacritty/src/display/mod.rs
index cbf2930a18..2e873c4e8f 100644
--- a/alacritty/src/display/mod.rs
+++ b/alacritty/src/display/mod.rs
@@ -470,7 +470,7 @@ impl Display {
     /// This call may block if vsync is enabled.
     pub fn draw<T: EventListener>(
         &mut self,
-        terminal: MutexGuard<'_, Term<T>>,
+        mut terminal: MutexGuard<'_, Term<T>>,
         message_buffer: &MessageBuffer,
         config: &Config,
         mouse: &Mouse,
@@ -505,6 +505,8 @@ impl Display {
         let vi_mode = terminal.mode().contains(TermMode::VI);
         let vi_mode_cursor = if vi_mode { Some(terminal.vi_mode_cursor) } else { None };

+        let graphics_queues = terminal.graphics_take_queues();
+
         // Drop terminal as early as possible to free lock.
         drop(terminal);

@@ -512,8 +514,13 @@ impl Display {
             api.clear(background_color);
         });

+        if let Some(graphics_queues) = graphics_queues {
+            self.renderer.graphics_run_updates(graphics_queues, &size_info);
+        }
+
         let mut lines = RenderLines::new();
         let mut urls = Urls::new();
+        let mut graphics_list = renderer::graphics::RenderList::default();

         // Draw grid.
         {
@@ -542,12 +549,17 @@ impl Display {
                     // Update underline/strikeout.
                     lines.update(&cell);

+                    // Track any graphic present in the cell.
+                    graphics_list.update(&cell);
+
                     // Draw the cell.
                     api.render_cell(cell, glyph_cache);
                 }
             });
         }

+        self.renderer.graphics_draw(graphics_list, &size_info);
+
         let mut rects = lines.rects(&metrics, &size_info);

         // Update visible URLs.
diff --git a/alacritty/src/renderer/graphics/draw.rs b/alacritty/src/renderer/graphics/draw.rs
new file mode 100644
index 0000000000..81013b858d
--- /dev/null
+++ b/alacritty/src/renderer/graphics/draw.rs
@@ -0,0 +1,242 @@
+//! This module implements the functionality to render graphic textures
+//! in the display.
+//!
+//! [`RenderList`] is used to track graphics in the visible cells. When all
+//! cells in the grid are read, graphics are rendered using the positions
+//! found in those cells.
+
+use std::collections::BTreeMap;
+use std::mem::{self, MaybeUninit};
+
+use crate::display::content::RenderableCell;
+use crate::gl::{self, types::*};
+use crate::renderer::graphics::{shader, GraphicsRenderer};
+
+use alacritty_terminal::graphics::GraphicId;
+use alacritty_terminal::index::{Column, Line};
+use alacritty_terminal::term::SizeInfo;
+
+use log::trace;
+
+/// Position to render each texture in the grid.
+struct RenderPosition {
+    column: Column,
+    line: Line,
+    offset_x: u16,
+    offset_y: u16,
+}
+
+/// Track textures to be rendered in the display.
+#[derive(Default)]
+pub struct RenderList {
+    items: BTreeMap<GraphicId, RenderPosition>,
+}
+
+impl RenderList {
+    /// Detects if the cell contains a graphic, then add it to the render list.
+    ///
+    /// The graphic is added only the first time it is found in a cell.
+    #[inline]
+    pub fn update(&mut self, cell: &RenderableCell) {
+        if let Some(graphic) = &cell.graphic {
+            let graphic_id = graphic.graphic_id();
+            if self.items.contains_key(&graphic_id) {
+                return;
+            }
+
+            let render_item = RenderPosition {
+                column: cell.point.column,
+                line: cell.point.line,
+                offset_x: graphic.offset_x,
+                offset_y: graphic.offset_y,
+            };
+
+            self.items.insert(graphic_id, render_item);
+        }
+    }
+
+    /// Returns `true` if there are no items to render.
+    #[inline]
+    pub fn is_empty(&self) -> bool {
+        self.items.is_empty()
+    }
+
+    /// Builds a list of vertex for the shader program.
+    pub fn build_vertices(self, renderer: &GraphicsRenderer) -> Vec<shader::Vertex> {
+        use shader::VertexSide::{BottomLeft, BottomRight, TopLeft, TopRight};
+
+        let mut vertices = Vec::new();
+
+        for (graphics_id, render_item) in self.items {
+            let graphic_texture = match renderer.graphic_textures.get(&graphics_id) {
+                Some(tex) => tex,
+                None => continue,
+            };
+
+            vertices.reserve(6);
+
+            let vertex = shader::Vertex {
+                texture_id: graphic_texture.texture.0,
+                sides: TopLeft,
+                column: render_item.column.0 as GLuint,
+                line: render_item.line.0 as GLuint,
+                height: graphic_texture.height,
+                width: graphic_texture.width,
+                offset_x: render_item.offset_x,
+                offset_y: render_item.offset_y,
+                base_cell_height: graphic_texture.cell_height,
+            };
+
+            vertices.push(vertex);
+
+            for &sides in &[TopRight, BottomLeft, TopRight, BottomRight, BottomLeft] {
+                vertices.push(shader::Vertex { sides, ..vertex });
+            }
+        }
+
+        vertices
+    }
+
+    /// Draw graphics in the display, using the graphics rendering shader
+    /// program.
+    pub fn draw(self, renderer: &GraphicsRenderer, size_info: &SizeInfo) {
+        let vertices = self.build_vertices(renderer);
+
+        // Initialize the rendering program.
+        unsafe {
+            gl::BindBuffer(gl::ARRAY_BUFFER, renderer.program.vbo);
+            gl::BindVertexArray(renderer.program.vao);
+
+            gl::UseProgram(renderer.program.id);
+
+            gl::Uniform2f(
+                renderer.program.u_cell_dimensions,
+                size_info.cell_width(),
+                size_info.cell_height(),
+            );
+            gl::Uniform2f(
+                renderer.program.u_view_dimensions,
+                size_info.width(),
+                size_info.height(),
+            );
+
+            gl::BlendFuncSeparate(gl::SRC_ALPHA, gl::ONE_MINUS_SRC_ALPHA, gl::SRC_ALPHA, gl::ONE);
+        }
+
+        // Array for storing the batch to render multiple graphics in a single call to the
+        // shader program.
+        //
+        // Each graphic requires 6 vertices (2 triangles to make a rectangle), and we will
+        // never have more than `TEXTURES_ARRAY_SIZE` graphics in a single call, so we set
+        // the array size to the maximum value that we can use.
+        let mut batch = [MaybeUninit::uninit(); shader::TEXTURES_ARRAY_SIZE * 6];
+        let mut batch_size = 0;
+
+        macro_rules! send_batch {
+            () => {
+                #[allow(unused_assignments)]
+                if batch_size > 0 {
+                    trace!("Call glDrawArrays with {} items", batch_size);
+
+                    unsafe {
+                        gl::BufferData(
+                            gl::ARRAY_BUFFER,
+                            (batch_size * mem::size_of::<shader::Vertex>()) as isize,
+                            batch.as_ptr().cast(),
+                            gl::STREAM_DRAW,
+                        );
+
+                        gl::DrawArrays(gl::TRIANGLES, 0, batch_size as GLint);
+                    }
+
+                    batch_size = 0;
+                }
+            };
+        }
+
+        // In order to send textures to the shader program we need to get a _slot_
+        // for every texture associated to a graphic.
+        //
+        // We have `u_textures.len()` slots available in each execution of the
+        // shader.
+        //
+        // For each slot we need three values:
+        //
+        // - The texture unit for `glActiveTexture` (`GL_TEXTUREi`).
+        // - The uniform location for `textures[i]`.
+        // - The index `i`, used to set the value of the uniform.
+        //
+        // These values are generated using the `tex_slots_generator` iterator.
+        //
+        // A single graphic has 6 vertices. All vertices will use the same texture
+        // slot. To detect if a texture has already a slot, we only need to compare
+        // with the last texture (`last_tex_slot`) because all the vertices of a
+        // single graphic are consecutive.
+        //
+        // When all slots are occupied, or the batch array is full, the current
+        // batch is sent and the iterator is reset.
+        //
+        // This logic could be simplified using the [Bindless Texture extension],
+        // but it is not a core feature of any OpenGL version, so hardware support
+        // is uncertain.
+        //
+        // [Bindless Texture extension]: https://www.khronos.org/opengl/wiki/Bindless_Texture
+
+        let tex_slots_generator = (gl::TEXTURE0..=gl::TEXTURE31)
+            .zip(renderer.program.u_textures.iter())
+            .zip(0_u32..)
+            .map(|((tex_enum, &u_texture), index)| (tex_enum, u_texture, index));
+
+        let mut tex_slots = tex_slots_generator.clone();
+
+        // Keep the last allocated slot in a `(texture id, index)` tuple.
+        let mut last_tex_slot = (0, 0);
+
+        for mut vertex in vertices {
+            // Check if we can reuse the last texture slot.
+            if last_tex_slot.0 != vertex.texture_id {
+                last_tex_slot = loop {
+                    match tex_slots.next() {
+                        None => {
+                            // No more slots. Send the batch and reset the iterator.
+                            send_batch!();
+                            tex_slots = tex_slots_generator.clone();
+                        },
+
+                        Some((tex_enum, u_texture, index)) => {
+                            unsafe {
+                                gl::ActiveTexture(tex_enum);
+                                gl::BindTexture(gl::TEXTURE_2D, vertex.texture_id);
+                                gl::Uniform1i(u_texture, index as GLint);
+                            }
+
+                            break (vertex.texture_id, index);
+                        },
+                    }
+                };
+            }
+
+            vertex.texture_id = last_tex_slot.1;
+            batch[batch_size] = MaybeUninit::new(vertex);
+            batch_size += 1;
+
+            if batch_size == batch.len() {
+                send_batch!();
+            }
+        }
+
+        send_batch!();
+
+        // Reset state.
+        unsafe {
+            gl::BlendFunc(gl::SRC1_COLOR, gl::ONE_MINUS_SRC1_COLOR);
+
+            gl::ActiveTexture(gl::TEXTURE0);
+            gl::BindTexture(gl::TEXTURE_2D, 0);
+
+            gl::UseProgram(0);
+            gl::BindVertexArray(0);
+            gl::BindBuffer(gl::ARRAY_BUFFER, 0);
+        }
+    }
+}
diff --git a/alacritty/src/renderer/graphics/mod.rs b/alacritty/src/renderer/graphics/mod.rs
new file mode 100644
index 0000000000..3fecd54933
--- /dev/null
+++ b/alacritty/src/renderer/graphics/mod.rs
@@ -0,0 +1,149 @@
+//! This module implements the functionality to support graphics in the grid.
+
+use std::mem;
+
+use alacritty_terminal::graphics::{ColorType, GraphicData, GraphicId, UpdateQueues};
+use alacritty_terminal::term::SizeInfo;
+
+use log::trace;
+use serde::{Deserialize, Serialize};
+
+use crate::gl;
+use crate::gl::types::*;
+use crate::renderer;
+
+use std::collections::HashMap;
+
+mod draw;
+mod shader;
+
+pub use draw::RenderList;
+
+/// Type for texture names generated in the GPU.
+#[derive(Serialize, Deserialize, Eq, PartialEq, Clone, Debug)]
+pub struct TextureName(GLuint);
+
+// In debug mode, check if the inner value was set to zero, so we can detect if
+// the associated texture was deleted from the GPU.
+#[cfg(debug_assertions)]
+impl Drop for TextureName {
+    fn drop(&mut self) {
+        if self.0 != 0 {
+            log::error!("Texture {} was not deleted.", self.0);
+        }
+    }
+}
+
+/// Texture for a graphic in the grid.
+#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
+pub struct GraphicTexture {
+    /// Texture in the GPU where the graphic pixels are stored.
+    texture: TextureName,
+
+    /// Cell height at the moment graphic was created.
+    ///
+    /// Used to scale it if the user increases or decreases the font size.
+    cell_height: f32,
+
+    /// Width in pixels of the graphic.
+    width: u16,
+
+    /// Height in pixels of the graphic.
+    height: u16,
+}
+
+#[derive(Debug)]
+pub struct GraphicsRenderer {
+    /// Program in the GPU to render graphics.
+    program: shader::GraphicsShaderProgram,
+
+    /// Collection to associate graphic identifiers with their textures.
+    graphic_textures: HashMap<GraphicId, GraphicTexture>,
+}
+
+impl GraphicsRenderer {
+    pub fn new() -> Result<GraphicsRenderer, renderer::Error> {
+        let program = shader::GraphicsShaderProgram::new()?;
+        Ok(GraphicsRenderer { program, graphic_textures: HashMap::default() })
+    }
+
+    /// Run the required actions to apply changes for the graphics in the grid.
+    #[inline]
+    pub fn run_updates(&mut self, update_queues: UpdateQueues, size_info: &SizeInfo) {
+        self.remove_graphics(update_queues.remove_queue);
+        self.upload_pending_graphics(update_queues.pending, size_info);
+    }
+
+    /// Release resources used by removed graphics.
+    fn remove_graphics(&mut self, removed_ids: Vec<GraphicId>) {
+        let mut textures = Vec::with_capacity(removed_ids.len());
+        for id in removed_ids {
+            if let Some(mut graphic_texture) = self.graphic_textures.remove(&id) {
+                // Reset the inner value of TextureName, so the Drop implementation
+                // (in debug mode) can verify that the texture was deleted.
+                textures.push(mem::take(&mut graphic_texture.texture.0));
+            }
+        }
+
+        trace!("Call glDeleteTextures with {} items", textures.len());
+
+        unsafe {
+            gl::DeleteTextures(textures.len() as GLint, textures.as_ptr());
+        }
+    }
+
+    /// Create new textures in the GPU, and upload the pixels to them.
+    fn upload_pending_graphics(&mut self, graphics: Vec<GraphicData>, size_info: &SizeInfo) {
+        for graphic in graphics {
+            let mut texture = 0;
+
+            unsafe {
+                gl::GenTextures(1, &mut texture);
+                trace!("Texture generated: {}", texture);
+
+                gl::BindTexture(gl::TEXTURE_2D, texture);
+                gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MAX_LEVEL, 0);
+                gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_WRAP_S, gl::CLAMP_TO_EDGE as GLint);
+                gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_WRAP_T, gl::CLAMP_TO_EDGE as GLint);
+                gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MIN_FILTER, gl::LINEAR as GLint);
+                gl::TexParameteri(gl::TEXTURE_2D, gl::TEXTURE_MAG_FILTER, gl::LINEAR as GLint);
+
+                let pixel_format = match graphic.color_type {
+                    ColorType::Rgb => gl::RGB,
+                    ColorType::Rgba => gl::RGBA,
+                };
+
+                gl::TexImage2D(
+                    gl::TEXTURE_2D,
+                    0,
+                    gl::RGBA as GLint,
+                    graphic.width as GLint,
+                    graphic.height as GLint,
+                    0,
+                    pixel_format,
+                    gl::UNSIGNED_BYTE,
+                    graphic.pixels.as_ptr().cast(),
+                );
+
+                gl::BindTexture(gl::TEXTURE_2D, 0);
+            }
+
+            let graphic_texture = GraphicTexture {
+                texture: TextureName(texture),
+                cell_height: size_info.cell_height(),
+                width: graphic.width as u16,
+                height: graphic.height as u16,
+            };
+
+            self.graphic_textures.insert(graphic.id, graphic_texture);
+        }
+    }
+
+    /// Draw graphics in the display.
+    #[inline]
+    pub fn draw(&mut self, render_list: RenderList, size_info: &SizeInfo) {
+        if !render_list.is_empty() {
+            render_list.draw(self, size_info);
+        }
+    }
+}
diff --git a/alacritty/src/renderer/graphics/shader.rs b/alacritty/src/renderer/graphics/shader.rs
new file mode 100644
index 0000000000..8d30d2a3d1
--- /dev/null
+++ b/alacritty/src/renderer/graphics/shader.rs
@@ -0,0 +1,199 @@
+use std::mem;
+
+use crate::gl;
+use crate::gl::types::*;
+use crate::renderer;
+
+/// Number of elements of the `textures[]` uniform.
+///
+/// If the file `graphics.f.glsl` is modified, this value has to be updated.
+pub(super) const TEXTURES_ARRAY_SIZE: usize = 16;
+
+/// Sides where the vertex is located.
+///
+/// * Bit 0 (LSB) is 0 for top and 1 for bottom.
+/// * Bit 1 is 0 for left and 1 for right.
+#[derive(Debug, Copy, Clone, PartialEq)]
+#[repr(u8)]
+pub enum VertexSide {
+    TopLeft = 0b00,
+    TopRight = 0b10,
+    BottomLeft = 0b01,
+    BottomRight = 0b11,
+}
+
+/// Vertex data to execute the graphics rendering program.
+#[derive(Debug, Copy, Clone, PartialEq)]
+pub struct Vertex {
+    /// Texture associated to the graphic.
+    pub texture_id: GLuint,
+
+    /// Sides where the vertex is located.
+    pub sides: VertexSide,
+
+    /// Column number in the grid where the left vertex is set.
+    pub column: GLuint,
+
+    /// Line where the top vertex is set.
+    pub line: GLuint,
+
+    /// Height, in pixels, of the texture.
+    pub height: u16,
+
+    /// Width, in pixels, of the texture.
+    pub width: u16,
+
+    /// Offset in the x direction.
+    pub offset_x: u16,
+
+    /// Offset in the y direction.
+    pub offset_y: u16,
+
+    /// Height, in pixels, of a single cell when the graphic was added.
+    pub base_cell_height: f32,
+}
+
+/// Sources for the graphics rendering program.
+static GRAPHICS_SHADER_F: &str = include_str!("../../../res/graphics.f.glsl");
+static GRAPHICS_SHADER_V: &str = include_str!("../../../res/graphics.v.glsl");
+
+/// Graphics rendering program.
+#[derive(Debug)]
+pub struct GraphicsShaderProgram {
+    /// Program id.
+    pub id: GLuint,
+
+    /// Uniform of the cell dimensions.
+    pub u_cell_dimensions: GLint,
+
+    /// Uniform of the view dimensions.
+    pub u_view_dimensions: GLint,
+
+    /// Uniform array of the textures.
+    pub u_textures: Vec<GLint>,
+
+    /// Vertex Array Object (VAO) for the fields of `Vertex`.
+    pub vao: GLuint,
+
+    /// Vertex Buffer Object (VBO) to send instances of `Vertex`.
+    pub vbo: GLuint,
+}
+
+impl GraphicsShaderProgram {
+    pub fn new() -> Result<Self, renderer::ShaderCreationError> {
+        let vertex_shader = renderer::create_shader(gl::VERTEX_SHADER, GRAPHICS_SHADER_V)?;
+        let fragment_shader = renderer::create_shader(gl::FRAGMENT_SHADER, GRAPHICS_SHADER_F)?;
+        let program = renderer::create_program(vertex_shader, fragment_shader)?;
+
+        let u_cell_dimensions;
+        let u_view_dimensions;
+        let u_textures;
+
+        unsafe {
+            gl::DeleteShader(fragment_shader);
+            gl::DeleteShader(vertex_shader);
+
+            gl::UseProgram(program);
+
+            // Uniform locations.
+
+            macro_rules! uniform {
+                ($name:literal) => {
+                    gl::GetUniformLocation(
+                        program,
+                        concat!($name, "\0").as_bytes().as_ptr().cast(),
+                    )
+                };
+
+                ($fmt:literal, $($arg:tt)+) => {
+                    match format!(concat!($fmt, "\0"), $($arg)+) {
+                        name => gl::GetUniformLocation(
+                            program,
+                            name.as_bytes().as_ptr().cast(),
+                        )
+                    }
+                };
+            }
+
+            u_cell_dimensions = uniform!("cellDimensions");
+            u_view_dimensions = uniform!("viewDimensions");
+            u_textures =
+                (0..TEXTURES_ARRAY_SIZE).map(|unit| uniform!("textures[{}]", unit)).collect();
+
+            gl::UseProgram(0);
+        }
+
+        let (vao, vbo) = define_vertex_attributes();
+
+        let shader =
+            Self { id: program, u_cell_dimensions, u_view_dimensions, u_textures, vao, vbo };
+
+        Ok(shader)
+    }
+}
+
+/// Build a Vertex Array Object (VAO) and a Vertex Buffer Object (VBO) for
+/// instances of the `Vertex` type.
+fn define_vertex_attributes() -> (GLuint, GLuint) {
+    let mut vao = 0;
+    let mut vbo = 0;
+
+    unsafe {
+        gl::GenVertexArrays(1, &mut vao);
+        gl::GenBuffers(1, &mut vbo);
+
+        gl::BindVertexArray(vao);
+        gl::BindBuffer(gl::ARRAY_BUFFER, vbo);
+
+        let mut attr_index = 0;
+
+        macro_rules! int_attr {
+            ($type:ident, $field:ident) => {
+                gl::VertexAttribIPointer(
+                    attr_index,
+                    1,
+                    gl::$type,
+                    mem::size_of::<Vertex>() as i32,
+                    memoffset::offset_of!(Vertex, $field) as *const _,
+                );
+
+                attr_index += 1;
+            };
+        }
+
+        macro_rules! float_attr {
+            ($type:ident, $field:ident) => {
+                gl::VertexAttribPointer(
+                    attr_index,
+                    1,
+                    gl::$type,
+                    gl::FALSE,
+                    mem::size_of::<Vertex>() as i32,
+                    memoffset::offset_of!(Vertex, $field) as *const _,
+                );
+
+                attr_index += 1;
+            };
+        }
+
+        int_attr!(UNSIGNED_INT, texture_id);
+        int_attr!(UNSIGNED_BYTE, sides);
+
+        float_attr!(UNSIGNED_INT, column);
+        float_attr!(UNSIGNED_INT, line);
+        float_attr!(UNSIGNED_SHORT, height);
+        float_attr!(UNSIGNED_SHORT, width);
+        float_attr!(UNSIGNED_SHORT, offset_x);
+        float_attr!(UNSIGNED_SHORT, offset_y);
+        float_attr!(FLOAT, base_cell_height);
+
+        for index in 0..attr_index {
+            gl::EnableVertexAttribArray(index);
+        }
+
+        gl::BindVertexArray(0);
+        gl::BindBuffer(gl::ARRAY_BUFFER, 0);
+    }
+
+    (vao, vbo)
+}
diff --git a/alacritty/src/renderer/mod.rs b/alacritty/src/renderer/mod.rs
index 4d752463ba..dc0a534508 100644
--- a/alacritty/src/renderer/mod.rs
+++ b/alacritty/src/renderer/mod.rs
@@ -14,6 +14,7 @@ use fnv::FnvHasher;
 use log::{error, info};
 use unicode_width::UnicodeWidthChar;

+use alacritty_terminal::graphics::UpdateQueues;
 use alacritty_terminal::index::Point;
 use alacritty_terminal::term::cell::Flags;
 use alacritty_terminal::term::color::Rgb;
@@ -24,8 +25,10 @@ use crate::config::ui_config::{Delta, UiConfig};
 use crate::display::content::RenderableCell;
 use crate::gl;
 use crate::gl::types::*;
+use crate::renderer::graphics::GraphicsRenderer;
 use crate::renderer::rects::{RectRenderer, RenderRect};

+pub mod graphics;
 pub mod rects;

 // Shader source.
@@ -439,6 +442,7 @@ pub struct QuadRenderer {
     batch: Batch,

     rect_renderer: RectRenderer,
+    graphics_renderer: GraphicsRenderer,
 }

 #[derive(Debug)]
@@ -638,6 +642,7 @@ impl QuadRenderer {
         let mut renderer = Self {
             program,
             rect_renderer: RectRenderer::new()?,
+            graphics_renderer: GraphicsRenderer::new()?,
             vao,
             ebo,
             vbo_instance,
@@ -682,6 +687,19 @@ impl QuadRenderer {
         }
     }

+    /// Run the required actions to apply changes for the graphics in the grid.
+    #[inline]
+    pub fn graphics_run_updates(&mut self, update_queues: UpdateQueues, size_info: &SizeInfo) {
+        self.graphics_renderer.run_updates(update_queues, size_info);
+    }
+
+    /// Draw graphics visible in the display.
+    #[inline]
+    pub fn graphics_draw(&mut self, render_list: graphics::RenderList, size_info: &SizeInfo) {
+        self.graphics_renderer.draw(render_list, size_info);
+        self.active_tex = 0;
+    }
+
     pub fn with_api<F, T>(&mut self, config: &UiConfig, props: &SizeInfo, func: F) -> T
     where
         F: FnOnce(RenderApi<'_>) -> T,
@@ -842,6 +860,7 @@ impl<'a> RenderApi<'a> {
                 point: Point::new(point.line, point.column + i),
                 character,
                 zerowidth: None,
+                graphic: None,
                 flags: Flags::empty(),
                 bg_alpha: 1.0,
                 fg,
diff --git a/alacritty/src/url.rs b/alacritty/src/url.rs
index d86b514a93..84b8584f18 100644
--- a/alacritty/src/url.rs
+++ b/alacritty/src/url.rs
@@ -202,6 +202,7 @@ mod tests {
             .map(|(i, character)| RenderableCell {
                 character,
                 zerowidth: None,
+                graphic: None,
                 point: Point::new(Line(0), Column(i)),
                 fg: Default::default(),
                 bg: Default::default(),
diff --git a/alacritty_terminal/src/ansi.rs b/alacritty_terminal/src/ansi.rs
index b46aec0b01..5e72b892df 100644
--- a/alacritty_terminal/src/ansi.rs
+++ b/alacritty_terminal/src/ansi.rs
@@ -10,6 +10,7 @@ use vte::{Params, ParamsIter};

 use alacritty_config_derive::ConfigDeserialize;

+use crate::graphics::{sixel, GraphicData};
 use crate::index::{Column, Line};
 use crate::term::color::Rgb;

@@ -136,6 +137,9 @@ enum Dcs {

     /// End of the synchronized update.
     SyncEnd,
+
+    /// Sixel data
+    SixelData(Box<sixel::Parser>),
 }

 /// The processor wraps a `vte::Parser` to ultimately call methods on a Handler.
@@ -244,6 +248,7 @@ impl Processor {
                     self.state.sync_state.timeout = Some(Instant::now() + SYNC_UPDATE_TIMEOUT);
                 },
                 Some(Dcs::SyncEnd) => self.stop_sync(handler, writer),
+                Some(Dcs::SixelData(_)) => (),
                 None => (),
             },
         }
@@ -465,6 +470,14 @@ pub trait Handler {

     /// Report text area size in characters.
     fn text_area_size_chars<W: io::Write>(&mut self, _: &mut W) {}
+
+    /// Create a parser for Sixel data.
+    fn start_sixel_graphic(&mut self, _params: &Params) -> Option<Box<sixel::Parser>> {
+        None
+    }
+
+    /// Insert a new graphic item.
+    fn insert_graphic(&mut self, _data: GraphicData, _palette: Option<Vec<Rgb>>) {}
 }

 /// Terminal cursor configuration.
@@ -538,6 +551,8 @@ pub enum Mode {
     LineFeedNewLine = 20,
     /// ?25
     ShowCursor = 25,
+    /// ?80
+    SixelScrolling = 80,
     /// ?1000
     ReportMouseClicks = 1000,
     /// ?1002
@@ -556,6 +571,8 @@ pub enum Mode {
     UrgencyHints = 1042,
     /// ?1049
     SwapScreenAndSetRestoreCursor = 1049,
+    /// Use a private palette for each new graphic.
+    SixelPrivateColorRegisters = 1070,
     /// ?2004
     BracketedPaste = 2004,
 }
@@ -577,6 +594,7 @@ impl Mode {
                 7 => Mode::LineWrap,
                 12 => Mode::BlinkingCursor,
                 25 => Mode::ShowCursor,
+                80 => Mode::SixelScrolling,
                 1000 => Mode::ReportMouseClicks,
                 1002 => Mode::ReportCellMouseMotion,
                 1003 => Mode::ReportAllMouseMotion,
@@ -586,6 +604,7 @@ impl Mode {
                 1007 => Mode::AlternateScroll,
                 1042 => Mode::UrgencyHints,
                 1049 => Mode::SwapScreenAndSetRestoreCursor,
+                1070 => Mode::SixelPrivateColorRegisters,
                 2004 => Mode::BracketedPaste,
                 _ => {
                     trace!("[unimplemented] primitive mode: {}", num);
@@ -918,6 +937,10 @@ where
                     self.state.dcs = Some(Dcs::SyncStart);
                 }
             },
+            ('q', []) => {
+                let parser = self.handler.start_sixel_graphic(params);
+                self.state.dcs = parser.map(Dcs::SixelData);
+            },
             _ => debug!(
                 "[unhandled hook] params={:?}, ints: {:?}, ignore: {:?}, action: {:?}",
                 params, intermediates, ignore, action
@@ -927,16 +950,29 @@ where

     #[inline]
     fn put(&mut self, byte: u8) {
-        debug!("[unhandled put] byte={:?}", byte);
+        match self.state.dcs {
+            Some(Dcs::SixelData(ref mut parser)) => {
+                if let Err(err) = parser.put(byte) {
+                    log::warn!("Failed to parse Sixel data: {}", err);
+                    self.state.dcs = None;
+                }
+            },
+
+            _ => debug!("[unhandled put] byte={:?}", byte),
+        }
     }

     #[inline]
     fn unhook(&mut self) {
-        match self.state.dcs {
+        match self.state.dcs.take() {
             Some(Dcs::SyncStart) => {
                 self.state.sync_state.timeout = Some(Instant::now() + SYNC_UPDATE_TIMEOUT);
             },
             Some(Dcs::SyncEnd) => (),
+            Some(Dcs::SixelData(parser)) => match parser.finish() {
+                Ok((graphic, palette)) => self.handler.insert_graphic(graphic, Some(palette)),
+                Err(err) => log::warn!("Failed to parse Sixel data: {}", err),
+            },
             _ => debug!("[unhandled unhook]"),
         }
     }
diff --git a/alacritty_terminal/src/graphics/mod.rs b/alacritty_terminal/src/graphics/mod.rs
new file mode 100644
index 0000000000..30424c2bea
--- /dev/null
+++ b/alacritty_terminal/src/graphics/mod.rs
@@ -0,0 +1,146 @@
+//! This module implements the logic to manage graphic items included in a
+//! `Grid` instance.
+
+pub mod sixel;
+
+use std::mem;
+use std::sync::{Arc, Weak};
+
+use parking_lot::Mutex;
+use serde::{Deserialize, Serialize};
+
+use crate::term::color::Rgb;
+
+/// Max allowed dimensions (width, height) for the graphic, in pixels.
+pub const MAX_GRAPHIC_DIMENSIONS: (usize, usize) = (4096, 4096);
+
+/// Unique identifier for every graphic added to a grid.
+#[derive(Serialize, Deserialize, Eq, PartialEq, Clone, Debug, Copy, Hash, PartialOrd, Ord)]
+pub struct GraphicId(u64);
+
+/// Reference to a texture stored in the display.
+///
+/// When all references to a single texture are removed, its identifier is
+/// added to the remove queue.
+#[derive(Clone, Debug)]
+pub struct TextureRef {
+    /// Graphic identifier.
+    pub id: GraphicId,
+
+    /// Queue to track removed references.
+    pub remove_queue: Weak<Mutex<Vec<GraphicId>>>,
+}
+
+impl PartialEq for TextureRef {
+    fn eq(&self, t: &Self) -> bool {
+        // Ignore remove_queue.
+        self.id == t.id
+    }
+}
+
+impl Eq for TextureRef {}
+
+impl Drop for TextureRef {
+    fn drop(&mut self) {
+        if let Some(remove_queue) = self.remove_queue.upgrade() {
+            remove_queue.lock().push(self.id);
+        }
+    }
+}
+
+/// Graphic data stored in a single cell.
+#[derive(Eq, PartialEq, Clone, Debug)]
+pub struct GraphicCell {
+    /// Texture to draw the graphic in this cell.
+    pub texture: Arc<TextureRef>,
+
+    /// Offset in the x direction.
+    pub offset_x: u16,
+
+    /// Offset in the y direction.
+    pub offset_y: u16,
+}
+
+impl GraphicCell {
+    /// Graphic identifier of the texture in this cell.
+    #[inline]
+    pub fn graphic_id(&self) -> GraphicId {
+        self.texture.id
+    }
+}
+
+/// Specifies the format of the pixel data.
+#[derive(Serialize, Deserialize, Eq, PartialEq, Clone, Debug, Copy)]
+pub enum ColorType {
+    /// 3 bytes per pixel (red, green, blue).
+    Rgb,
+
+    /// 4 bytes per pixel (red, green, blue, alpha).
+    Rgba,
+}
+
+/// Defines a single graphic read from the PTY.
+#[derive(Serialize, Deserialize, Eq, PartialEq, Clone, Debug)]
+pub struct GraphicData {
+    /// Graphics identifier.
+    pub id: GraphicId,
+
+    /// Width, in pixels, of the graphic.
+    pub width: usize,
+
+    /// Height, in pixels, of the graphic.
+    pub height: usize,
+
+    /// Color type of the pixels.
+    pub color_type: ColorType,
+
+    /// Pixels data.
+    pub pixels: Vec<u8>,
+}
+
+/// Queues to add or to remove the textures in the display.
+pub struct UpdateQueues {
+    /// Graphics read from the PTY.
+    pub pending: Vec<GraphicData>,
+
+    /// Graphics removed from the grid.
+    pub remove_queue: Vec<GraphicId>,
+}
+
+/// Track changes in the grid to add or to remove graphics.
+#[derive(Clone, Debug, Default)]
+pub struct Graphics {
+    /// Last generated identifier.
+    pub last_id: u64,
+
+    /// New graphics, received from the PTY.
+    pub pending: Vec<GraphicData>,
+
+    /// Graphics removed from the grid.
+    pub remove_queue: Arc<Mutex<Vec<GraphicId>>>,
+
+    /// Shared palette for Sixel graphics.
+    pub sixel_shared_palette: Option<Vec<Rgb>>,
+}
+
+impl Graphics {
+    /// Generate a new graphic identifier.
+    pub fn next_id(&mut self) -> GraphicId {
+        self.last_id += 1;
+        GraphicId(self.last_id)
+    }
+
+    /// Get queues to update graphics in the grid.
+    ///
+    /// If all queues are empty, it returns `None`.
+    pub fn take_queues(&mut self) -> Option<UpdateQueues> {
+        let mut remove_queue = self.remove_queue.lock();
+        if remove_queue.is_empty() && self.pending.is_empty() {
+            return None;
+        }
+
+        let remove_queue = mem::take(&mut *remove_queue);
+
+        Some(UpdateQueues { pending: mem::take(&mut self.pending), remove_queue })
+    }
+}
diff --git a/alacritty_terminal/src/graphics/sixel.rs b/alacritty_terminal/src/graphics/sixel.rs
new file mode 100644
index 0000000000..476089cc9c
--- /dev/null
+++ b/alacritty_terminal/src/graphics/sixel.rs
@@ -0,0 +1,772 @@
+//! This module implements a parser for the Sixel protocol, and it is based on the
+//! chapter [SIXEL GRAPHICS EXTENSION] of the DEC reference manual.
+//!
+//! [SIXEL GRAPHICS EXTENSION]: https://archive.org/details/bitsavers_decstandar0VideoSystemsReferenceManualDec91_74264381/page/n907/mode/2up
+//!
+//! # Limitations
+//!
+//! The parser have the following limitations:
+//!
+//! * A single image can use up to 1024 different colors.
+//!
+//!   The Sixel reference requires 256, but allow more colors.
+//!
+//! * Image dimensions are limited to 4096 x 4096.
+//!
+//! * Pixel aspect ratio parameters are ignored.
+//!
+//!   The Sixel references specifies some parameters to change the pixel
+//!   aspect ratio, but multiple implementations always use 1:1, so these
+//!   parameters have no real effect.
+use std::cmp::max;
+use std::fmt;
+use std::mem;
+
+use crate::graphics::{ColorType, GraphicData, GraphicId, MAX_GRAPHIC_DIMENSIONS};
+use crate::term::color::Rgb;
+
+use log::trace;
+use vte::Params;
+
+/// Type for color registers.
+#[derive(Copy, Clone, Default, Debug, PartialEq, Eq)]
+struct ColorRegister(u16);
+
+/// Number of color registers.
+const MAX_COLOR_REGISTERS: usize = 1024;
+
+/// Color register for transparent pixels.
+const REG_TRANSPARENT: ColorRegister = ColorRegister(u16::MAX);
+
+/// Number of parameters allowed in a single Sixel command.
+const MAX_COMMAND_PARAMS: usize = 5;
+
+#[derive(Debug)]
+pub enum Error {
+    /// Image dimensions are too big.
+    TooBigImage { width: usize, height: usize },
+
+    /// A component in a color introducer is not valid.
+    InvalidColorComponent { register: u16, component_value: u16 },
+
+    /// The coordinate system to define the color register is not valid.
+    InvalidColorCoordinateSystem { register: u16, coordinate_system: u16 },
+}
+
+impl fmt::Display for Error {
+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match self {
+            Error::TooBigImage { width, height } => {
+                write!(fmt, "The image dimensions are too big ({}, {})", width, height)
+            },
+
+            Error::InvalidColorComponent { register, component_value } => {
+                write!(fmt, "Invalid color component {} for register {}", component_value, register)
+            },
+
+            Error::InvalidColorCoordinateSystem { register, coordinate_system } => {
+                write!(
+                    fmt,
+                    "Invalid color coordinate system {} for register {}",
+                    coordinate_system, register
+                )
+            },
+        }
+    }
+}
+
+/// Commands found in the data stream.
+#[derive(Debug)]
+enum SixelCommand {
+    /// Specifies a repeat count before a sixel.
+    ///
+    /// Its only parameter is the repeat count.
+    RepeatIntroducer,
+
+    /// Defines raster attributes for the following data.
+    ///
+    /// It expects 4 parameters:
+    ///
+    /// 1. Pixel aspect ratio numerator (relative height).
+    /// 2. Pixel aspect ratio denominator (relative width).
+    /// 3. Horizontal Extent.
+    /// 4. Vertical Extent.
+    SetRasterAttributes,
+
+    /// Starts a color selection sequence.
+    ///
+    /// The first parameter is the register number.
+    ///
+    /// Optionally, it can receive 4 more parameters:
+    ///
+    /// 1. Color coordinate system. `1` for HLS, `2` for RGB.
+    /// 2. Hue angle, or red.
+    /// 3. Lightness, or green.
+    /// 4. Saturation, or blue.
+    ColorIntroducer,
+
+    /// Moves the active position to the graphic left margin.
+    CarriageReturn,
+
+    /// Moves the active position to the graphic left margin
+    /// and one row of sixels.
+    NextLine,
+}
+
+/// Parser for commands found in the picture definition.
+#[derive(Debug)]
+struct CommandParser {
+    /// Active command.
+    command: SixelCommand,
+
+    /// Parameter values.
+    ///
+    /// If a value is greater than `u16::MAX`, it will be kept as `u16::MAX`.
+    ///
+    /// Parameters after `MAX_COMMAND_PARAMS` are ignored.
+    params: [u16; MAX_COMMAND_PARAMS],
+
+    /// Current position.
+    params_position: usize,
+}
+
+impl CommandParser {
+    fn new(command: SixelCommand) -> CommandParser {
+        CommandParser { command, params: [0; MAX_COMMAND_PARAMS], params_position: 0 }
+    }
+
+    fn put(&mut self, byte: u8) {
+        let pos = self.params_position;
+        if pos < MAX_COMMAND_PARAMS {
+            match byte {
+                b'0'..=b'9' => {
+                    self.params[pos] =
+                        self.params[pos].saturating_mul(10).saturating_add((byte - b'0') as u16);
+                },
+
+                b';' => {
+                    self.params_position += 1;
+                },
+
+                _ => (), // Ignore unknown bytes.
+            }
+        }
+    }
+
+    /// Apply the execution of the active command to the parser.
+    fn finish(self, parser: &mut Parser) -> Result<(), Error> {
+        match self.command {
+            SixelCommand::RepeatIntroducer => {
+                parser.repeat_count = self.params[0] as usize;
+            },
+
+            SixelCommand::SetRasterAttributes => {
+                if self.params_position >= 3 {
+                    let width = self.params[2] as usize;
+                    let height = self.params[3] as usize;
+                    parser.ensure_size(width, height)?;
+                }
+            },
+
+            SixelCommand::ColorIntroducer => {
+                let register = ColorRegister(self.params[0]);
+
+                if self.params_position >= 4 {
+                    macro_rules! p {
+                        ($index:expr) => {
+                            match self.params[$index] {
+                                x if x <= 100 => x,
+                                x => {
+                                    return Err(Error::InvalidColorComponent {
+                                        register: register.0,
+                                        component_value: x,
+                                    })
+                                },
+                            }
+                        };
+                    }
+
+                    let (r, g, b) = match self.params[1] {
+                        // HLS.
+                        1 => hls_to_rgb(p!(2), p!(3), p!(4)),
+
+                        // RGB.
+                        2 => (p!(2), p!(3), p!(4)),
+
+                        // Invalid coordinate system.
+                        x => {
+                            return Err(Error::InvalidColorCoordinateSystem {
+                                register: register.0,
+                                coordinate_system: x,
+                            })
+                        },
+                    };
+
+                    parser.set_color_register(register, r, g, b);
+                }
+
+                parser.selected_color_register = register;
+            },
+
+            SixelCommand::CarriageReturn => {
+                parser.x = 0;
+            },
+
+            SixelCommand::NextLine => {
+                parser.x = 0;
+                parser.y += 6;
+            },
+        }
+
+        Ok(())
+    }
+}
+
+/// A group of 6 vertical pixels.
+struct Sixel(u8);
+
+impl Sixel {
+    /// Create a new sixel.
+    ///
+    /// It expects the byte value from the picture definition stream.
+    #[inline]
+    fn new(byte: u8) -> Sixel {
+        debug_assert!((0x3F..=0x7E).contains(&byte));
+        Sixel(byte - 0x3F)
+    }
+
+    /// Return how many rows are printed in the sixel.
+    #[inline]
+    fn height(&self) -> usize {
+        8 - self.0.leading_zeros() as usize
+    }
+
+    /// Return an iterator to get dots in the sixel.
+    #[inline]
+    fn dots(&self) -> impl Iterator<Item = bool> {
+        let sixel = self.0;
+        (0..6).map(move |position| sixel & (1 << position) != 0)
+    }
+}
+
+/// Parser of the picture definition in a Sixel data stream.
+#[derive(Default, Debug)]
+pub struct Parser {
+    /// Active command to be parsed.
+    command_parser: Option<CommandParser>,
+
+    /// Current picture width.
+    width: usize,
+
+    /// Current picture height.
+    height: usize,
+
+    /// Current picture pixels.
+    pixels: Vec<ColorRegister>,
+
+    /// Indicates the register color for empty pixels.
+    background: ColorRegister,
+
+    /// RGB values for every register.
+    color_registers: Vec<Rgb>,
+
+    /// Selected color register.
+    selected_color_register: ColorRegister,
+
+    /// Repeat count for the next sixel.
+    repeat_count: usize,
+
+    /// Horizontal position of the active sixel.
+    x: usize,
+
+    /// Vertical position of the active sixel.
+    y: usize,
+}
+
+impl Parser {
+    /// Creates a new parser.
+    pub fn new(params: &Params, shared_palette: Option<Vec<Rgb>>) -> Parser {
+        trace!("Start Sixel parser");
+
+        let mut parser = Parser::default();
+
+        // According to the Sixel reference, the second parameter (Ps2) is
+        // the background selector. It controls how to show pixels without
+        // an explicit color, and it accepts the following values:
+        //
+        //   0   device default action
+        //   1   no action (don't change zero value pixels)
+        //   2   set zero value pixels to background color
+        //
+        // We replicate the xterm's behaviour:
+        //
+        //  - If it is set to `1`, the background is transparent.
+        //  - For any other value, the background is the color register 0.
+
+        let ps2 = params.iter().nth(1).and_then(|param| param.iter().next().copied()).unwrap_or(0);
+        parser.background = if ps2 == 1 { REG_TRANSPARENT } else { ColorRegister(0) };
+
+        if let Some(color_registers) = shared_palette {
+            parser.color_registers = color_registers;
+        } else {
+            init_color_registers(&mut parser);
+        }
+
+        parser
+    }
+
+    /// Parse a byte from the Sixel stream.
+    pub fn put(&mut self, byte: u8) -> Result<(), Error> {
+        match byte {
+            b'!' => self.start_command(SixelCommand::RepeatIntroducer)?,
+
+            b'"' => self.start_command(SixelCommand::SetRasterAttributes)?,
+
+            b'#' => self.start_command(SixelCommand::ColorIntroducer)?,
+
+            b'$' => self.start_command(SixelCommand::CarriageReturn)?,
+
+            b'-' => self.start_command(SixelCommand::NextLine)?,
+
+            b'0'..=b'9' | b';' => {
+                if let Some(command_parser) = &mut self.command_parser {
+                    command_parser.put(byte);
+                }
+            },
+
+            0x3F..=0x7E => self.add_sixel(Sixel::new(byte))?,
+
+            _ => {
+                // Invalid bytes are ignored, but we still have to finish any
+                // active command.
+
+                self.finish_command()?;
+            },
+        }
+
+        Ok(())
+    }
+
+    #[inline]
+    fn start_command(&mut self, command: SixelCommand) -> Result<(), Error> {
+        self.finish_command()?;
+        self.command_parser = Some(CommandParser::new(command));
+        Ok(())
+    }
+
+    #[inline]
+    fn finish_command(&mut self) -> Result<(), Error> {
+        if let Some(command_parser) = self.command_parser.take() {
+            command_parser.finish(self)?;
+        }
+
+        Ok(())
+    }
+
+    /// Set the RGB color for a register.
+    ///
+    /// Color components are expected to be in the range of 0..=100.
+    fn set_color_register(&mut self, register: ColorRegister, r: u16, g: u16, b: u16) {
+        let register = register.0 as usize;
+
+        if register >= MAX_COLOR_REGISTERS {
+            return;
+        }
+
+        if self.color_registers.len() <= register {
+            self.color_registers.resize(register + 1, Rgb { r: 0, g: 0, b: 0 })
+        }
+
+        let r = ((r * 255 + 50) / 100) as u8;
+        let g = ((g * 255 + 50) / 100) as u8;
+        let b = ((b * 255 + 50) / 100) as u8;
+        self.color_registers[register] = Rgb { r, g, b };
+    }
+
+    /// Check if the current picture is big enough for the given dimensions. If
+    /// not, the picture is resized.
+    fn ensure_size(&mut self, width: usize, height: usize) -> Result<(), Error> {
+        // Do nothing if the current picture is big enough.
+        if self.width >= width && self.height >= height {
+            return Ok(());
+        }
+
+        if width > MAX_GRAPHIC_DIMENSIONS.0 || height > MAX_GRAPHIC_DIMENSIONS.1 {
+            return Err(Error::TooBigImage { width, height });
+        }
+
+        trace!(
+            "Set Sixel image dimensions to {}x{}",
+            max(self.width, width),
+            max(self.height, height),
+        );
+
+        // If there is no current picture, creates a new one.
+        if self.pixels.is_empty() {
+            self.width = width;
+            self.height = height;
+            self.pixels = vec![self.background; width * height];
+            return Ok(());
+        }
+
+        // If current width is big enough, we only need to add more pixels
+        // after the current buffer.
+        if self.width >= width {
+            self.pixels.resize(height * self.width, self.background);
+            self.height = height;
+            return Ok(());
+        }
+
+        // At this point, we know that the new width is greater than the
+        // current one, so we have to extend the buffer and move the rows to
+        // their new positions.
+        let height = usize::max(height, self.height);
+
+        self.pixels.resize(height * width, self.background);
+
+        for y in (0..self.height).rev() {
+            for x in (0..self.width).rev() {
+                let old = y * self.width + x;
+                let new = y * width + x;
+                self.pixels.swap(old, new);
+            }
+        }
+
+        self.width = width;
+        self.height = height;
+        Ok(())
+    }
+
+    /// Add a sixel using the selected color register, and move the active
+    /// position.
+    fn add_sixel(&mut self, sixel: Sixel) -> Result<(), Error> {
+        self.finish_command()?;
+
+        // Take the repeat count and reset it.
+        //
+        // `max` function is used because the Sixel reference specifies
+        // that a repeat count of zero implies a repeat count of 1.
+        let repeat = max(1, mem::take(&mut self.repeat_count));
+
+        self.ensure_size(self.x + repeat, self.y + sixel.height())?;
+
+        if sixel.0 != 0 {
+            let mut index = self.width * self.y + self.x;
+            for dot in sixel.dots() {
+                if dot {
+                    for pixel in &mut self.pixels[index..index + repeat] {
+                        *pixel = self.selected_color_register;
+                    }
+                }
+
+                index += self.width;
+            }
+        }
+
+        self.x += repeat;
+
+        Ok(())
+    }
+
+    /// Returns the final graphic to append to the grid, with the palette
+    /// built in the process.
+    pub fn finish(mut self) -> Result<(GraphicData, Vec<Rgb>), Error> {
+        self.finish_command()?;
+
+        trace!(
+            "Finish Sixel parser: width={}, height={}, color_registers={}",
+            self.width,
+            self.height,
+            self.color_registers.len()
+        );
+
+        let mut rgba_pixels = Vec::with_capacity(self.pixels.len() * 4);
+
+        for &register in &self.pixels {
+            let pixel = {
+                if register == REG_TRANSPARENT {
+                    [0; 4]
+                } else {
+                    match self.color_registers.get(register.0 as usize) {
+                        None => [0, 0, 0, 255],
+                        Some(color) => [color.r, color.g, color.b, 255],
+                    }
+                }
+            };
+
+            rgba_pixels.extend_from_slice(&pixel);
+        }
+
+        let data = GraphicData {
+            id: GraphicId(0),
+            height: self.height,
+            width: self.width,
+            color_type: ColorType::Rgba,
+            pixels: rgba_pixels,
+        };
+
+        Ok((data, self.color_registers))
+    }
+}
+
+/// Compute a RGB value from HLS.
+///
+/// Input and output values are in the range of `0..=100`.
+///
+/// The implementation is a direct port of the same function in the
+/// xterm's code.
+#[allow(clippy::many_single_char_names)]
+fn hls_to_rgb(h: u16, l: u16, s: u16) -> (u16, u16, u16) {
+    if s == 0 {
+        return (l, l, l);
+    }
+
+    let hs = ((h + 240) / 60) % 6;
+    let lv = l as f64 / 100.0;
+
+    let c2 = f64::abs((2.0 * lv as f64) - 1.0);
+    let c = (1.0 - c2) * (s as f64 / 100.0);
+    let x = if hs & 1 == 1 { c } else { 0.0 };
+
+    let rgb = match hs {
+        0 => (c, x, 0.),
+        1 => (x, c, 0.),
+        2 => (0., c, x),
+        3 => (0., x, c),
+        4 => (x, 0., c),
+        _ => (c, 0., c),
+    };
+
+    fn clamp(x: f64) -> u16 {
+        let x = x * 100. + 0.5;
+        if x > 100. {
+            100
+        } else if x < 0. {
+            0
+        } else {
+            x as u16
+        }
+    }
+
+    let m = lv - 0.5 * c;
+    let r = clamp(rgb.0 + m);
+    let g = clamp(rgb.1 + m);
+    let b = clamp(rgb.2 + m);
+
+    (r, g, b)
+}
+
+/// Initialize the color registers using the colors from the VT-340 terminal.
+///
+/// There is no official documentation about these colors, but multiple Sixel
+/// implementations assume this palette.
+fn init_color_registers(parser: &mut Parser) {
+    parser.set_color_register(ColorRegister(0), 0, 0, 0);
+    parser.set_color_register(ColorRegister(1), 20, 20, 80);
+    parser.set_color_register(ColorRegister(2), 80, 13, 13);
+    parser.set_color_register(ColorRegister(3), 20, 80, 20);
+    parser.set_color_register(ColorRegister(4), 80, 20, 80);
+    parser.set_color_register(ColorRegister(5), 20, 80, 80);
+    parser.set_color_register(ColorRegister(6), 80, 80, 20);
+    parser.set_color_register(ColorRegister(7), 53, 53, 53);
+    parser.set_color_register(ColorRegister(8), 26, 26, 26);
+    parser.set_color_register(ColorRegister(9), 33, 33, 60);
+    parser.set_color_register(ColorRegister(10), 60, 26, 26);
+    parser.set_color_register(ColorRegister(11), 33, 60, 33);
+    parser.set_color_register(ColorRegister(12), 60, 33, 60);
+    parser.set_color_register(ColorRegister(13), 33, 60, 60);
+    parser.set_color_register(ColorRegister(14), 60, 60, 33);
+    parser.set_color_register(ColorRegister(15), 80, 80, 80);
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+    use std::fs;
+    use std::path::Path;
+
+    macro_rules! put_bytes {
+        ($parser:expr, $data:expr) => {
+            #[allow(clippy::string_lit_as_bytes)]
+            for &byte in $data.as_bytes() {
+                let _ = $parser.put(byte);
+            }
+        };
+    }
+
+    #[test]
+    fn parse_command_parameters() {
+        let mut command_parser = CommandParser::new(SixelCommand::ColorIntroducer);
+        put_bytes!(command_parser, "65535;1;2;3;4;5");
+
+        assert_eq!(command_parser.params_position, 5);
+        assert_eq!(command_parser.params[0], 65535);
+        assert_eq!(command_parser.params[1], 1);
+        assert_eq!(command_parser.params[2], 2);
+        assert_eq!(command_parser.params[3], 3);
+        assert_eq!(command_parser.params[4], 4);
+    }
+
+    #[test]
+    fn set_color_registers() {
+        let mut parser = Parser::default();
+        put_bytes!(parser, "#1;2;30;100;0#200;1;20;75;50.");
+
+        assert!(parser.color_registers.len() >= 200);
+
+        assert_eq!(parser.color_registers[1], Rgb { r: 77, g: 255, b: 0 });
+        assert_eq!(parser.color_registers[200], Rgb { r: 161, g: 161, b: 224 });
+
+        assert_eq!(parser.selected_color_register.0, 200);
+    }
+
+    #[test]
+    fn convert_hls_colors() {
+        // This test converts values from HLS to RBG, and compares those
+        // results with the values generated by the xterm implementation
+        // of the same function.
+
+        assert_eq!(hls_to_rgb(100, 60, 60), (84, 36, 84));
+        assert_eq!(hls_to_rgb(60, 100, 60), (100, 100, 100));
+        assert_eq!(hls_to_rgb(30, 30, 60), (12, 12, 48));
+        assert_eq!(hls_to_rgb(100, 90, 100), (100, 80, 100));
+        assert_eq!(hls_to_rgb(100, 0, 90), (0, 0, 0));
+        assert_eq!(hls_to_rgb(0, 90, 30), (87, 87, 93));
+        assert_eq!(hls_to_rgb(60, 0, 60), (0, 0, 0));
+        assert_eq!(hls_to_rgb(30, 0, 0), (0, 0, 0));
+        assert_eq!(hls_to_rgb(30, 90, 30), (87, 87, 93));
+        assert_eq!(hls_to_rgb(30, 30, 30), (21, 21, 39));
+        assert_eq!(hls_to_rgb(90, 100, 60), (100, 100, 100));
+        assert_eq!(hls_to_rgb(0, 0, 0), (0, 0, 0));
+        assert_eq!(hls_to_rgb(30, 0, 90), (0, 0, 0));
+        assert_eq!(hls_to_rgb(100, 60, 90), (96, 24, 96));
+        assert_eq!(hls_to_rgb(30, 30, 0), (30, 30, 30));
+    }
+
+    #[test]
+    fn resize_picture() -> Result<(), Error> {
+        let mut parser = Parser { background: REG_TRANSPARENT, ..Parser::default() };
+
+        const WIDTH: usize = 30;
+        const HEIGHT: usize = 20;
+
+        // Initialize a transparent picture with Set Raster Attributes.
+        put_bytes!(parser, format!("\"1;1;{};{}.", WIDTH, HEIGHT));
+
+        assert_eq!(parser.width, WIDTH);
+        assert_eq!(parser.height, HEIGHT);
+        assert_eq!(parser.pixels.len(), WIDTH * HEIGHT);
+
+        assert!(parser.pixels.iter().all(|&pixel| pixel == REG_TRANSPARENT));
+
+        // Fill each row with a different color register.
+        for (n, row) in parser.pixels.chunks_mut(WIDTH).enumerate() {
+            row.iter_mut().for_each(|pixel| *pixel = ColorRegister(n as u16));
+        }
+
+        // Increase height.
+        //
+        // New rows must be transparent.
+        parser.ensure_size(WIDTH, HEIGHT + 5)?;
+
+        assert_eq!(parser.width, WIDTH);
+        assert_eq!(parser.height, HEIGHT + 5);
+        assert_eq!(parser.pixels.len(), WIDTH * (HEIGHT + 5));
+
+        for (n, row) in parser.pixels.chunks(WIDTH).enumerate() {
+            let expected = if n < HEIGHT { ColorRegister(n as u16) } else { REG_TRANSPARENT };
+            assert!(row.iter().all(|pixel| *pixel == expected));
+        }
+
+        // Increase both width and height.
+        //
+        // New rows and columns must be transparent.
+        parser.ensure_size(WIDTH + 5, HEIGHT + 10)?;
+
+        assert_eq!(parser.width, WIDTH + 5);
+        assert_eq!(parser.height, HEIGHT + 10);
+        assert_eq!(parser.pixels.len(), (WIDTH + 5) * (HEIGHT + 10));
+
+        for (n, row) in parser.pixels.chunks(WIDTH + 5).enumerate() {
+            if n < HEIGHT {
+                assert!(row[..WIDTH].iter().all(|pixel| *pixel == ColorRegister(n as u16)));
+                assert!(row[WIDTH..].iter().all(|pixel| *pixel == REG_TRANSPARENT));
+            } else {
+                assert!(row.iter().all(|pixel| *pixel == REG_TRANSPARENT));
+            }
+        }
+
+        Ok(())
+    }
+
+    #[test]
+    fn sixel_height() {
+        assert_eq!(Sixel(0b000000).height(), 0);
+        assert_eq!(Sixel(0b000001).height(), 1);
+        assert_eq!(Sixel(0b000100).height(), 3);
+        assert_eq!(Sixel(0b000101).height(), 3);
+        assert_eq!(Sixel(0b101111).height(), 6);
+    }
+
+    #[test]
+    fn sixel_positions() {
+        macro_rules! dots {
+            ($sixel:expr) => {
+                Sixel($sixel).dots().collect::<Vec<_>>()
+            };
+        }
+
+        assert_eq!(dots!(0b000000), &[false, false, false, false, false, false,]);
+        assert_eq!(dots!(0b000001), &[true, false, false, false, false, false,]);
+        assert_eq!(dots!(0b000100), &[false, false, true, false, false, false,]);
+        assert_eq!(dots!(0b000101), &[true, false, true, false, false, false,]);
+        assert_eq!(dots!(0b101111), &[true, true, true, true, false, true,]);
+    }
+
+    #[test]
+    fn load_sixel_files() {
+        let images_dir = Path::new(concat!(env!("CARGO_MANIFEST_DIR"), "/tests/sixel"));
+
+        let test_images = ["testimage_im6", "testimage_libsixel", "testimage_ppmtosixel"];
+
+        for test_image in &test_images {
+            // Load Sixel data.
+            let mut sixel = {
+                let mut path = images_dir.join(test_image);
+                path.set_extension("sixel");
+                fs::read(path).unwrap()
+            };
+
+            // Remove DCS sequence from Sixel data.
+            let dcs_end = sixel.iter().position(|&byte| byte == b'q').unwrap();
+            sixel.drain(..=dcs_end);
+
+            // Remove ST, which can be either "1B 5C" or "9C". To simplify the
+            // code, we assume that any ESC byte is the start of the ST.
+            if let Some(pos) = sixel.iter().position(|&b| b == 0x1B || b == 0x9C) {
+                sixel.truncate(pos);
+            }
+
+            // Parse the data and get the GraphicData item.
+            let mut parser = Parser::default();
+            for byte in sixel {
+                parser.put(byte).unwrap();
+            }
+
+            let graphics = parser.finish().unwrap().0;
+
+            assert_eq!(graphics.width, 64);
+            assert_eq!(graphics.height, 64);
+
+            // Read the RGBA stream generated by ImageMagick and compare it
+            // with our picture.
+            let expected_rgba = {
+                let mut path = images_dir.join(test_image);
+                path.set_extension("rgba");
+                fs::read(path).unwrap()
+            };
+
+            assert_eq!(graphics.pixels, expected_rgba);
+        }
+    }
+}
diff --git a/alacritty_terminal/src/lib.rs b/alacritty_terminal/src/lib.rs
index 5f80e2833d..59b2fe0505 100644
--- a/alacritty_terminal/src/lib.rs
+++ b/alacritty_terminal/src/lib.rs
@@ -8,6 +8,7 @@ pub mod ansi;
 pub mod config;
 pub mod event;
 pub mod event_loop;
+pub mod graphics;
 pub mod grid;
 pub mod index;
 pub mod selection;
diff --git a/alacritty_terminal/src/term/cell.rs b/alacritty_terminal/src/term/cell.rs
index 91ee33910c..250a96f258 100644
--- a/alacritty_terminal/src/term/cell.rs
+++ b/alacritty_terminal/src/term/cell.rs
@@ -4,6 +4,7 @@ use bitflags::bitflags;
 use serde::{Deserialize, Serialize};

 use crate::ansi::{Color, NamedColor};
+use crate::graphics::GraphicCell;
 use crate::grid::{self, GridCell};
 use crate::index::Column;

@@ -24,6 +25,7 @@ bitflags! {
         const STRIKEOUT                 = 0b0000_0010_0000_0000;
         const LEADING_WIDE_CHAR_SPACER  = 0b0000_0100_0000_0000;
         const DOUBLE_UNDERLINE          = 0b0000_1000_0000_0000;
+        const GRAPHICS                  = 0b0001_0000_0000_0000;
     }
 }

@@ -53,6 +55,9 @@ impl ResetDiscriminant<Color> for Cell {
 #[derive(Serialize, Deserialize, Default, Debug, Clone, Eq, PartialEq)]
 struct CellExtra {
     zerowidth: Vec<char>,
+
+    #[serde(skip)]
+    graphic: Option<Box<GraphicCell>>,
 }

 /// Content and attributes of a single cell in the terminal grid.
@@ -99,6 +104,21 @@ impl Cell {
             self.extra = None;
         }
     }
+
+    /// Graphic present in the cell.
+    #[inline]
+    pub fn graphic(&self) -> Option<&GraphicCell> {
+        self.extra.as_deref().and_then(|extra| extra.graphic.as_deref())
+    }
+
+    /// Write the graphic data in the cell.
+    #[inline]
+    pub fn set_graphic(&mut self, graphic_cell: GraphicCell) {
+        let mut extra = self.extra.get_or_insert_with(Default::default);
+        extra.graphic = Some(Box::new(graphic_cell));
+
+        self.flags_mut().insert(Flags::GRAPHICS);
+    }
 }

 impl GridCell for Cell {
@@ -114,7 +134,8 @@ impl GridCell for Cell {
                     | Flags::STRIKEOUT
                     | Flags::WRAPLINE
                     | Flags::WIDE_CHAR_SPACER
-                    | Flags::LEADING_WIDE_CHAR_SPACER,
+                    | Flags::LEADING_WIDE_CHAR_SPACER
+                    | Flags::GRAPHICS,
             )
             && self.extra.as_ref().map(|extra| extra.zerowidth.is_empty()) != Some(false)
     }
diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index b853cebafb..c7d1d9a235 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -9,12 +9,16 @@ use bitflags::bitflags;
 use log::{debug, trace};
 use serde::{Deserialize, Serialize};
 use unicode_width::UnicodeWidthChar;
+use vte::Params;

 use crate::ansi::{
     self, Attr, CharsetIndex, Color, CursorShape, CursorStyle, Handler, NamedColor, StandardCharset,
 };
 use crate::config::Config;
 use crate::event::{Event, EventListener};
+use crate::graphics::{
+    sixel, GraphicCell, GraphicData, Graphics, TextureRef, UpdateQueues, MAX_GRAPHIC_DIMENSIONS,
+};
 use crate::grid::{Dimensions, DisplayIter, Grid, Scroll};
 use crate::index::{self, Boundary, Column, Direction, IndexRange, Line, Point, Side};
 use crate::selection::{Selection, SelectionRange};
@@ -62,6 +66,8 @@ bitflags! {
         const ALTERNATE_SCROLL    = 0b0000_1000_0000_0000_0000;
         const VI                  = 0b0001_0000_0000_0000_0000;
         const URGENCY_HINTS       = 0b0010_0000_0000_0000_0000;
+        const SIXEL_SCROLLING     = 0b0100_0000_0000_0000_0000;
+        const SIXEL_PRIV_PALETTE  = 0b1000_0000_0000_0000_0000;
         const ANY                 = std::u32::MAX;
     }
 }
@@ -72,6 +78,8 @@ impl Default for TermMode {
             | TermMode::LINE_WRAP
             | TermMode::ALTERNATE_SCROLL
             | TermMode::URGENCY_HINTS
+            | TermMode::SIXEL_SCROLLING
+            | TermMode::SIXEL_PRIV_PALETTE
     }
 }

@@ -276,6 +284,9 @@ pub struct Term<T> {
     /// Information about cell dimensions.
     cell_width: usize,
     cell_height: usize,
+
+    /// Data to add graphics to a grid.
+    graphics: Graphics,
 }

 impl<T> Term<T> {
@@ -320,6 +331,7 @@ impl<T> Term<T> {
             selection: None,
             cell_width: size.cell_width as usize,
             cell_height: size.cell_height as usize,
+            graphics: Graphics::default(),
         }
     }

@@ -475,6 +487,12 @@ impl<T> Term<T> {
         &mut self.grid
     }

+    /// Get queues to update graphic data. If both queues are empty, it returns
+    /// `None`.
+    pub fn graphics_take_queues(&mut self) -> Option<UpdateQueues> {
+        self.graphics.take_queues()
+    }
+
     /// Resize terminal to new dimensions.
     pub fn resize(&mut self, size: SizeInfo) {
         self.cell_width = size.cell_width as usize;
@@ -1009,7 +1027,7 @@ impl<T: EventListener> Handler for Term<T> {
         match intermediate {
             None => {
                 trace!("Reporting primary device attributes");
-                let _ = writer.write_all(b"\x1b[?6c");
+                let _ = writer.write_all(b"\x1b[?4;6c");
             },
             Some('>') => {
                 trace!("Reporting secondary device attributes");
@@ -1580,6 +1598,10 @@ impl<T: EventListener> Handler for Term<T> {
                 style.blinking = true;
                 self.event_proxy.send_event(Event::CursorBlinkingChange(true));
             },
+            ansi::Mode::SixelScrolling => self.mode.insert(TermMode::SIXEL_SCROLLING),
+            ansi::Mode::SixelPrivateColorRegisters => {
+                self.mode.insert(TermMode::SIXEL_PRIV_PALETTE)
+            },
         }
     }

@@ -1622,6 +1644,11 @@ impl<T: EventListener> Handler for Term<T> {
                 style.blinking = false;
                 self.event_proxy.send_event(Event::CursorBlinkingChange(false));
             },
+            ansi::Mode::SixelScrolling => self.mode.remove(TermMode::SIXEL_SCROLLING),
+            ansi::Mode::SixelPrivateColorRegisters => {
+                self.graphics.sixel_shared_palette = None;
+                self.mode.remove(TermMode::SIXEL_PRIV_PALETTE);
+            },
         }
     }

@@ -1741,6 +1768,88 @@ impl<T: EventListener> Handler for Term<T> {
     fn text_area_size_chars<W: io::Write>(&mut self, writer: &mut W) {
         let _ = write!(writer, "\x1b[8;{};{}t", self.screen_lines(), self.cols());
     }
+
+    fn start_sixel_graphic(&mut self, params: &Params) -> Option<Box<sixel::Parser>> {
+        let palette = self.graphics.sixel_shared_palette.take();
+        Some(Box::new(sixel::Parser::new(params, palette)))
+    }
+
+    fn insert_graphic(&mut self, graphic: GraphicData, palette: Option<Vec<Rgb>>) {
+        // Store last palette if we receive a new one, and it is shared.
+        if let Some(palette) = palette {
+            if !self.mode.contains(TermMode::SIXEL_PRIV_PALETTE) {
+                self.graphics.sixel_shared_palette = Some(palette);
+            }
+        }
+
+        if graphic.width > MAX_GRAPHIC_DIMENSIONS.0 || graphic.height > MAX_GRAPHIC_DIMENSIONS.1 {
+            return;
+        }
+
+        let width = graphic.width as u16;
+        let height = graphic.height as u16;
+
+        if width == 0 || height == 0 {
+            return;
+        }
+
+        // Add the graphic data to the pending queue.
+        let graphic_id = self.graphics.next_id();
+        self.graphics.pending.push(GraphicData { id: graphic_id, ..graphic });
+
+        // If SIXEL_SCROLLING is enabled, the start of the graphic is the
+        // cursor position, and the grid can be scrolled if the graphic is
+        // larger than the screen. The cursor is moved to the next line
+        // after the graphic.
+        //
+        // If it is disabled, the graphic starts at (0, 0), the grid is never
+        // scrolled, and the cursor position is unmodified.
+
+        let scrolling = self.mode.contains(TermMode::SIXEL_SCROLLING);
+
+        // Fill the cells under the graphic.
+        //
+        // The cell in the first column contains a reference to the graphic,
+        // with the offset from the start. Rest of the cells are empty.
+
+        let left = if scrolling { self.grid.cursor.point.column.0 } else { 0 };
+
+        let texture = Arc::new(TextureRef {
+            id: graphic_id,
+            remove_queue: Arc::downgrade(&self.graphics.remove_queue),
+        });
+
+        for (top, offset_y) in (0..).zip((0..height).step_by(self.cell_height)) {
+            let line = if scrolling {
+                self.grid.cursor.point.line
+            } else {
+                // Check if the image is beyond the screen limit.
+                if top >= self.screen_lines().0 {
+                    break;
+                }
+
+                Line(top)
+            };
+
+            // Store a reference to the graphic in the first column.
+            let graphic_cell = GraphicCell { texture: texture.clone(), offset_x: 0, offset_y };
+            let mut cell = Cell::default();
+            cell.set_graphic(graphic_cell);
+            self.grid[line][Column(left)] = cell;
+
+            for col in left + 1..self.cols().0 {
+                self.grid[line][Column(col)] = Cell::default();
+            }
+
+            if scrolling {
+                self.linefeed();
+            }
+        }
+
+        if scrolling {
+            self.carriage_return();
+        }
+    }
 }

 /// Terminal version for escape sequence reports.
diff --git a/alacritty_terminal/tests/sixel/README.md b/alacritty_terminal/tests/sixel/README.md
new file mode 100644
index 0000000000..c01deae9b6
--- /dev/null
+++ b/alacritty_terminal/tests/sixel/README.md
@@ -0,0 +1,50 @@
+# Images for Sixel tests
+
+The files in this directory are used to test the Sixel parser against images
+generated by real-world software:
+
+* `testimage_im6.sixel`
+
+    Generated with ImageMagick 6.9.10.
+
+    ```bash
+    convert "$SOURCE" testimage_im6.sixel
+    ```
+
+* `testimage_libsixel.sixel`
+
+    Generated with libsixel 1.8.6.
+
+    ```bash
+    img2sixel -o testimage_libsixel.sixel "$SOURCE"
+    ```
+
+* `testimage_ppmtosixel.sixel`
+
+    Generated with Netpbm 10.
+
+    ```bash
+    pngtopnm "$SOURCE" \
+        | ppmquant 256 \
+        | ppmtosixel   \
+        > testimage_ppmtosixel.sixel
+    ```
+
+In the previous commands, `$SOURCE` is defined as:
+
+    SOURCE="$(git rev-parse --show-toplevel)/alacritty/alacritty.png"
+
+The image is the [Alacritty icon](../../../extra/logo/compat/alacritty-term.png).
+
+To verify the results of the parser we include the raw RGBA data for each
+image. It was generated with this script:
+
+```bash
+for IMG in *.sixel
+do
+    convert "$IMG" png:- | convert -depth 8 png:- rgba:"${IMG/.sixel/.rgba}"
+done
+```
+
+We have to convert the Sixel to PNG before RGBA because, for some reason,
+ImageMagick can't transform from Sixel to RGBA directly.
diff --git a/alacritty_terminal/tests/sixel/testimage_im6.rgba b/alacritty_terminal/tests/sixel/testimage_im6.rgba
new file mode 100644
index 0000000000000000000000000000000000000000..af6abfa317ddf0eb6330f672df51eb850593f8b5
GIT binary patch
literal 16384
zcmeI3e`H<R7RN6UB1EWADpZLOAxan_$_O!(C>5R%LtR3J@ra>HcuIsQ;}OFnhEXEa
zFjRQvpECdCpJ9|y>M@3)LWC$)`p<s*vva=puCwnx=bn3WGH>2{3Cmi0?X}ll-?e|8
zyU$6Z(Qu6`y2`=T90+sZbY{Q>n)O^X@8yin76x3P&oaK`c}DM+8!ktyzHF)K%Nf02
zZ@54ko?CkC%c3nWNAzK*;XXX|w40}odkxp3XI{4S+?O*dTkF3~4!A(mo_qS;<Im9@
zUluKTIit6C8!ksa4<|k+r}qZjTaQ1c;|C1~ovaPGW1oi{`CJ@FbmDVxvgrv9dHgMo
zEb=)y@pS5Qkt3gr(~Qmziub#pAFa8cHy?J=6R(4O-K(t<dg|*eVY{2@;1T_@cdmmc
z=~<?S7twQHS3s{{JajEOTyw88is!)5(UChmJah*K2mcoYRxpzX`2PNWz-_r?a)PX~
z<wde>Q>Cr7mn@!YZ|fvmF4@K>o#kLxS^fN(`QF}MYb@%BGliW#c6WE(&dyF(+S=Mm
z+LY;w>Z<gYvgyTNDrYvQ$jxTcjgODJ;n6WSHg-;uV@|zvvbB6@WVGeO>SI|xhDNWI
z+Lzg>F7{2CIxvAvIS_8RrHP3NN8F?1w?Z3uEK7%P$z{B%9WlyJ)i$!XJk=IVV6#|L
zIcSaj#Izf$fr!icxjixI?oZzev^sIqS(=)h%-Py@7nPY?F@EMkoR1rmQ|EKK2JFOq
zee!k=)Be=x`SYcoGYzNiqBx7%gP*aD@y2Cx6xLEr_-#ClZ|nKm;I_KUngd{p#~<wM
z^^o##nfM=1UvK}W&~FR!AlY+lY|iSEh2P>$$#vk5=e#hynjOkvwYbCYD~}%=*~h%d
zZ)}$;gP*mnu@?52*MUFPKYN~jLw4iXrhHsP7mt68Tjk5be=zI!J@Y%dOvd&iSW|7g
z;pf?k99#x|_B7oafLk&=l>J>oj(dIG`ylx7DV!Q_TSmqvJcre||Nm|FdJglM!Hb+L
zXZI_#NsVK_I*osfm$Id9_<P-h*mGVl3<ZqBDvrLau3xOFc6R(N-dF}dwkaR|=-A72
zKi1-mxxXKJGJic#tXFw?=4Nei*zu1sQ`YaOy77Pa=}5Q}6ee-*$LI?}mR_8DMB4U~
z^Hdv+zi=uCD#M}a>FL_We`d-*@A*4G-HC!t^0%M*-+I{|!+tNlwV^G)7i4!4&YlJ~
z;nbMN<vPco`7K;AUzlm1@pGR{6x!kABDmEy#xLCBD^K=9ZtBGUufGhQ-+%kLZ12H;
zTpI4cgwEOo*|)=oFkFN)|Cx`%E55n8nbToY$Nsl6ce4{u_Aa0~H{O8>T?hWm9$!_k
zmz_;uvh!c#O&-XB@-RE&&wuW1dOZK*zF*w)`(74*c;}JHybIt=jQyi)%@=H&?Ky+5
z*uK}Y#$PyvIp&N%_b0vjxAyqZd!CqYFPil{^-1o2fV$XTWya3-(W`9n$Cz!oj`<G`
z-fi)INAbfcv%e^I<{+dpeaCIoK9{#1=O+Hy|CrkrtCcr4HbUJ+@iUKqZ4REl+w(bS
zz321t!TtQY`r*x~gM=TBjcp?tpQ&|Y+m^|!Y0ezs6n2%x<MTgW*JXWB$6lqFV}5t8
zedf(9eeU#k``&|A4zP*asf_P#{TJ11{{y$M!bQ^0&dy$F|NrOeNdA2;?{@vzA3eyQ
zc{_)%1m7XsxUtQ>6VBcb<J;QxA`8F8F3idSJRbjE`e1#f;zqajnK|?PzIXh-1wY7R
z({lkE_r=&2`I)`l-amSY&EmIsW4WL4*SdUqf9yPNy}!@+?;C?|e5!rst!zJQgU=*%
z!h=8Bw7vsi{4-zlA-i5U_`w$ARe61VJ=FC({v9!!9K<m{e|^@0ADzV$a%p@BKY3BU
zt$jB+HU3~0Zpr<OKYfQet8X=;xb2+1c4x)?c-#R$=%^Epu$HVJd{g#3_57%IMO@=A
zoQ%6<%lpOu!$ZICW%1c>R=#WI&%CjX@7?B4&YgX1=KvWUb&8*Jhql(2Wcrd_8MkLw
zjNf9mazFTaW>9RF^R13O^N4litKZz*3+H})*T#>Gjyj8nw)n6<CG(rn+IEvQ|1DNz
z-ib<w+z<Z0ua1Q{!?#I%pOn$7N1b>1BkRxHjeY0#-+XlM{kTKO=%|Zv;6wf_r_b27
ztQ?QOaKlC9p;!Fu>&M%J=P~kKmZ87iyU`KjwZ*0z{nojamoA)poP)^dsEaY+!}<)e
z&o6!2GbL^pmo0wbP4Qmwv+sp((ZKD$z0$X7e3O-mk2N{`^*eX#z=b{U<y#kIbauTe
z{#JhFTmATQ?wP``EwxE;;ZI?<x+?f>oQID_!gqJ^_jqOVbNI`{Fy3DrIR`QJ=u&Z`
z+ihNRAHMdvg~&rj^sP2FCh07%ihq87zVh=gdyry*>-$4wd*<0VkVls`-0(Lpta;Ww
z_($)4(ZUkjv%j|Rn;g(z)qOC9e|2@$#RUGU?>`t9VYb|kON=Fy{j=`SKR&oYp9AuM
ztmogPz0aBEne7Le7>e3hz3^MS%zIl#t~&m#OTM)X@%V2mZCoo0-G8SIKYkhTha8m5
zePO_7_@>okwtexPXKJ5OJ8|%XEyf#{tE_)~KD<BP#t#0B-h9=0<|zitM^?65_>pa0
zN@jiITm4v0EU7kDR|Ws_@^a<zKiVEn#`5LrjpROVV?pLwm$47$o_X$#?Q9v}7Pn+#
zv34mr#t&A;9&Y8T^MB#aEtjGybCLKMPu4xuZSNKye5d+ECz~QJ{K8wrtKu)}r>Y*z
z>;c11e(D-~Ri9;ce>VKYI<odnpt88D)K!^3MfjJNmRf6oIq^r0Ke#ya%g+5O*sI#a
z_$_W^Q9t;r<Ufv+d#><%KfCve>+2}nZ!d+v2)FPrE-qGn{vk%N+kPaA7vZ43n@y^%
z+Qd9%YjxlUn{XC!?nT187Ty6}GVwj8?SmL?IVHz!uu19SwqOEVjGHx2UPRRMJ6QKa
z@K~0vh^u{EU!;%iY*}r@ZCxyv*-&S(YcB8%fL{3jNFMham+Owj`bP#k{{vHZKmRTM
r?EgWLi~nTYybsf}-DSjqf9@0U&6>B^ujJzY3B1b9Rc`*5=fJ-Kz)kc#

literal 0
HcmV?d00001

diff --git a/alacritty_terminal/tests/sixel/testimage_im6.sixel b/alacritty_terminal/tests/sixel/testimage_im6.sixel
new file mode 100644
index 0000000000..80752a7510
--- /dev/null
+++ b/alacritty_terminal/tests/sixel/testimage_im6.sixel
@@ -0,0 +1 @@
+␛P0;0;0q"1;1;64;64#0;2;3;5;6#1;2;3;6;7#2;2;4;6;8#3;2;8;8;8#4;2;11;11;11#5;2;6;11;13#6;2;8;14;17#7;2;10;15;16#8;2;11;16;16#9;2;9;15;19#10;2;8;16;21#11;2;8;17;22#12;2;14;14;14#13;2;16;15;15#14;2;18;16;15#15;2;17;17;17#16;2;20;18;15#17;2;19;14;15#18;2;20;19;15#19;2;22;21;14#20;2;20;20;20#21;2;23;23;23#22;2;36;14;12#23;2;33;18;12#24;2;35;22;12#25;2;48;17;9#26;2;39;22;11#27;2;50;20;9#28;2;26;18;13#29;2;32;17;13#30;2;26;24;13#31;2;29;22;13#32;2;35;26;12#33;2;40;28;11#34;2;41;32;11#35;2;46;36;10#36;2;44;31;10#37;2;7;24;35#38;2;18;30;37#39;2;6;29;43#40;2;7;27;39#41;2;6;30;45#42;2;19;31;38#43;2;27;27;27#44;2;30;30;30#45;2;33;33;33#46;2;36;36;36#47;2;39;39;39#48;2;42;42;42#49;2;45;45;45#50;2;49;49;49#51;2;51;23;9#52;2;65;16;6#53;2;66;20;6#54;2;82;20;3#55;2;88;17;1#56;2;93;18;1#57;2;88;15;1#58;2;89;20;1#59;2;93;20;1#60;2;89;24;1#61;2;93;23;1#62;2;53;27;9#63;2;53;27;9#64;2;55;32;8#65;2;57;36;8#66;2;68;25;5#67;2;70;31;5#68;2;72;36;5#69;2;63;25;7#70;2;66;32;6#71;2;58;39;7#72;2;68;39;6#73;2;73;41;5#74;2;71;47;5#75;2;76;30;4#76;2;84;26;3#77;2;86;34;2#78;2;89;27;1#79;2;94;26;1#80;2;90;29;0#81;2;92;30;1#82;2;94;28;1#83;2;94;30;1#84;2;90;33;0#85;2;90;36;0#86;2;93;31;1#87;2;95;33;0#88;2;95;36;0#89;2;78;38;4#90;2;87;39;2#91;2;77;47;4#92;2;82;47;3#93;2;92;40;1#94;2;91;42;0#95;2;91;38;0#96;2;95;39;0#97;2;96;42;0#98;2;89;45;2#99;2;91;45;0#100;2;92;49;0#101;2;96;45;0#102;2;96;48;0#103;2;81;49;41#104;2;81;47;40#105;2;78;53;4#106;2;85;56;3#107;2;92;52;0#108;2;92;55;0#109;2;91;53;2#110;2;96;52;0#111;2;97;54;0#112;2;97;55;0#113;2;92;58;0#114;2;93;61;0#115;2;97;58;0#116;2;98;61;0#117;2;97;59;0#118;2;93;64;0#119;2;98;64;0#120;2;98;67;0#121;2;94;66;0#122;2;81;51;41#123;2;82;52;41#124;2;82;55;41#125;2;82;58;41#126;2;83;61;41#127;2;83;64;41#128;2;83;67;41#129;2;84;70;41#130;2;84;71;40#131;2;5;35;53#132;2;5;40;62#133;2;5;42;64#134;2;4;46;71#135;2;8;45;69#136;2;4;48;75#137;2;35;51;61#138;2;35;53;64#139;2;4;51;80#140;2;5;56;88#141;2;3;60;97#142;2;2;62;100#143;2;4;62;100#144;2;4;59;95#145;2;6;63;100#146;2;10;65;100#147;2;13;66;100#148;2;22;70;100#149;2;35;75;100#150;2;43;78;100#151;2;49;80;100#152;2;52;52;52#153;2;54;54;54#154;2;58;58;58#155;2;61;61;61#156;2;65;65;65#157;2;66;66;66#158;2;71;71;71#159;2;54;71;82#160;2;73;85;93#161;2;65;85;98#162;2;67;84;94#163;2;75;90;100#164;2;78;78;78#165;2;76;91;100#166;2;87;95;100#167;2;91;96;100#168;2;94;98;100#169;2;91;96;100#170;2;100;100;100#171;2;96;98;100#172;2;0;0;0#172~~~N!56FN~~~$#57???OO#55OO#58!4O#60OOO#78OOO#80!4O#84O#81O#88!4G#96GGG#97GG#94!4O#99!5O#107O?OO?O#128?!7_#129___#130___$#104???_#103!5_??_#123!7_!4?_#125_?!5_?_#102???GGG#127_?!7_#116??GGG#114!4O#118OOO#121O$#56!4?GG#59GGG#61GGG#79GG?G#83GGG#124!4_??_#95???OO#126_?!6_?_#100?O#111?G#108O?!4O#113OO#119!4G#120GGG$#122!9?__#82???G#87!4?!4G#86O#85!5O#93??O#101!4G#110???!5G#112?G#115!4G-#156G][MCEECCEECECEECEECEC!4ECECEECECEECECEEECACCEECECECCEECECM[]KW$#157C?A@B@@BB@@B@B@@B@@B@B!4@B@B@@B@B@@B@B@@@B@BB@@B@B@BB@@B@B@B?AC$#155o__oG#4O?_??_#152!4?G!5?G!5?GG#2!4?O!9?O!6?O!6?O#0_#12_#155__o_$#164A@#158@#12?_#0_#153!9G?!5G?!5G??!19G?!10G#47O#158?@#164@A$#172@#47???O#154G#5_?__?!4_?!9_?!9_?__?!14_?!4_#4O#172!4?@$#2!6?O??O?O?O??O#0!6?O#1!11?O!9?O#152??G$#3!7?OO?O?O?Oo?!6O?Oo!7O?O?OOo!4O?O?!4O?OOoOOO$#4!35?_#155!7?C-#154wgoo#4@#2~#6!15~n~~{~^B!8?B^!5~n!14~#1B#4A#154wgow$#155EVNN#7A#9!16?O??A#29?_??@@!6?_#9!5?O#2!14?{#7O#155FVNE$#156@#12???{#5!19?@#13??C!7?@C#12!22?l#156???@$#25!27?G!8?G$#54!27?O!8?O$#61!27?!7_o__$#52!28?A!6?A$#56!28?CEEEMEEC$#59!28?!4WOWGW$#17!28?@#22??!4@-#153{wY{#12B#1K#6!6~v!11~F@#79EECAAA!4?CE#6@N!18~#2~#12T#153]ww{$#154BFDB#13{#2r#9!6?G#7!11?G#13A!5?__!5?A#23O#13!19?i#154@FFB$#152??_#29!21?O#76G!5?GG!5?G#66_#152!20?_$#66!24?_#83Oooo_O??Oo_ooO$#27!25?C#82GGG[GCCMG]GG#27C$#87!25?_#53@#61@B@D@B@F@B#53@#87_$#81!30?_??_$#51!31?OO-#50goo_#13E#0O#6!12~n~~^F!6?_{^^{_!6?F^!8~v!6~#1B#14s#50o_oo$#152VMH^#14g#2N#9!12?O#14??_?@#87AFBABB!4?BBABBE#17@#24G#15_#9!8?G#2!6?{#15J#152N^EN$#153?@A#15?@#3_#96!16?___o__!8?__o___#137!20?G$??C#16?O#24!17?G#88W[G[[K!6?K[[KWW#67O#153!20?@$#67!22?O#51A#86@#83??@!8?@#86??@#51A$#77!23?C#62!4?_!6?_$#85!28?O#7O!4?O#77O!4?C$#26!29?G!4?G$#75!29?C!4?C$#28!30?A#10_#9_#19A$#69!30?@#53??@-#49{wuw#14B#2~#6~~z!8~^~N@!6?w}NB??BN}g!6?@N!13~#0A#15[#49ysws$#50BFHF#15S#9???C#7!8?_??A#97CFEEME#31C!8?C#7_!5?A#18O#1!13?@#16@#50DJFJ$#20!4?g#16!14?O#101o!4WO#8_#70A!8?A#97!5EC#24C#64_#2!13?{#20_$#64!19?_#24C#102!4_#98_#33O#13?@#138_!4?_#14@#5O#96!5@#63@#68G#28!15?A$#68!20?G#63@#93?@???@!8?@#33O#101WWWwWO$#90!21?A#96??@@@#10??O#159G??G#11O#89??G#98_#102__?__$#89!26?G#170???_{{_#90!8?A$#38!30?C#137@@#42C$#167!30?O#160AA#169O-#47o__O#15@#2~#6!10~^F!6?o{~~@!6?@~~wo!6?F^!7~z~~#2~#15H#48}]K^$M[^m#20}#8!11?_#14G#110GIMKKC#31G#18A#37??A!6?A#9??C#102BBB@B#98@#7@#19G#8_#9!7?C#20???u#49@@B$@B?@#65!13?O#111o!4OG#72C#64@#40??_!6?_#16??A#31G#110CKMKMG#65O#47!14?_o_$#109!17?_#7@#102C@!4B#133???O!6?O#64??@#72C#111G!4Oo#109_$#33!18?A#112!4_#36_#135!4?C!6?C#36!4?_#112!4_#26A$#73!18?C#98@#92???O#140!4?G!6?G#92!4?O#73!4?C$#145!29?_!4?_$#146!29?O!4?O$#148!29?G!4?G$#151!29?C!4?C$#162!29?@!4?@$#165!29?A!4?A$#149!30?_??_$#161!30?O??O$#166!30?G??G$#168!30?C??C$#170!30?BNNB$#167!31?__$#171!31?OO-#46!4w#20b#1G#6!7~|NB!5?_w}!4~}o!4?o}!4~}w!6?BN|!7~#2~#20N#46wwws$#47!4F#21[#2v#9!7?A#8O!8?@#9!4?@!6?@!6?_!7?A#21!8?o#47FFFJ$#34!14?_#116_WIW[[#32O#18C#11!6?G!4?G#8!5?@!8?O$#19!15?C#74A!4?G#65A#134!6?A???OA#71!6?A!6?G#34_$#71!15?G#115CDEBAF#108@#144!6?@!4?@#14!6?C#74G!4?A#19C$#113!15?O#119_o__#106_#41!8?C#131_??_#39C#109!6?@#115@?AFF#33@#114O$#33!16?@#112?@?@#141!9?G??G#117!8?EEC$#145!30?A??E#32!8?O#119O!5_$#147!30?@??@#116!9?GWWW[$#143!30?C?G#112!10?@@$#136!30?O#142wo#106!10?_$#146!31?CC$#150!31?AA$#165!31?@#163@-#44O___#21~#2~#6!8~{{{[{{{}!8~W??{!9~!6{s!5~^~~#2~#21~#44_?O_$#45m][^#30!10?!6A#8A#37!9?@_?@#8!9?A#30!6A#5!5?_#45!4?]}n]$#46@@B#105!11?@#119!5@#35@#5!9?_#39OO#35!10?@#119!5@#9G#46!10?@@?@$#9!17?_???@!8?E??A#105!15?@$#132!31?GG$#141!31?AA$#136!31?C#11_$#142!31?@#139C$#145!32?@-#44BJBBC#48C?C??C#9!5?@#5@??@?@!7?@@#38??_#30__#48???C?C!8?C!6?C#44KFFJF$#46G?_#49?A?C?CC?!10C?!5C?!12C?C?!8C?!6C?A#45?_#172_o$o_#1???@#3!25A?AAA?!8A?!4A?!8A#2@#31_#46???G$#45C#43S[{x!26wowwWOW!21wWPwWS$#15!5?A#6!10@??@@?@?!7@??!12@?@?@?!9@#15A$#48!21?C!5?C#44???G???G#4!8?A!4?A#38!8?_$#4!31?A#2???A#5!8?@?@?@-#172!64N-␛\
\ No newline at end of file
diff --git a/alacritty_terminal/tests/sixel/testimage_libsixel.rgba b/alacritty_terminal/tests/sixel/testimage_libsixel.rgba
new file mode 100644
index 0000000000000000000000000000000000000000..a9e1d6c737a986b0d104673decc18d73ea4d7c5d
GIT binary patch
literal 16384
zcmeI3EqE$B5QdR;NHh|MMB<RuNMs!ni9@0*ag~+V9eMPTb(P4v%A9%AoxQW^WV;kX
z?*+v7>})p4=AB7qe^`3GUg+I)^FcKSMt8k1?H{Ruv_C+zQ7@cKW9cg+*xKg$dfX3t
z8B3J(u~$vRHhP=(LamwDR`;^6nv1Pkh;8*C`>Lhbs+HJQYuT^#zUhUit!z_0N||aW
zc1AlnkLQDt#Q#-z+hl$4Dn4jPeDGRnFZ@=o;se!Qd=Mq<drvaHeWivU#3y_4gX&Fu
zVYL^3)Dl1JjZ$AshfN=hMx(G^ufy-vL-@1)hBnfsO<Osh)1w?~(@u`J=}C^~^eo35
zZ8n<#GxK0Jn}w&Rr>oR8vtMh>yKrx}+rS#RB*D~$eX&@C{$LpT{r+W1m|#nNu-ol|
z6?yRvc6@L_f(bUu>e(<y{^2O}3urtVhWT*dien|tNuL^1kJ*;h@h`y6ICfKWk2#Y2
z6eEt6<nI#ylKk{-c|DstC4A6z{+HxmjRyZdQ^>t`{d{3;>YS6G>w;BDex5BnW?M#`
zlKhs{vrF-l^X&6en@!zQ`#|Tv$85_=@yEPpo}t_LOXR_y<j1G=`vQ4x?qbvClye}*
zpWfq^h(GUDx-i>1v?;-#@}~PG_<2v#ct<4fN!Zu-C%I#nz(1P|U3Qp>ahw~KKT<!O
zG7swfPvf2LpE~~JvXqN`-j8uEgzeQiWgh$qe%R`Fp)eX*w&){s%+{liQ>=rZ;9nE_
z4A)fFg>qr%>d}YRJ7)V6{4cP}yWdp5W_O>MC`;?HPalI5Jd2&1KjuA$9j1rr=leU#
zJbudP>zLTnHpkC<Z!6Xtb&ow?E}r}j;Kh?Nj(I-t=F6euQ+~_p*{9%-c~5@lX#Cz&
z?c4P{5MLu@iTNVa?$|tdPW~JRzxP;<`Fa<S@^g$jU-?bzAF@3ce?5=kNMx^hjQyXN
zeU#;h*TSS7{p8k-ZQEw&_*bh{up$Q3ZR@M;Sj=P2_+e<|vDrg-e}9kai>-aeyqRh5
z<xOq()mHf}t7jj}AM@T)VxNfXm>uKh`A^M{ZI9*pI3^FCgMU1h`<R4V_igORd2dzh
znFH8155_r^>4$SzUv;(5!M|O|{hs~pzOwl}+g|g?c{=xXYx5v=Y2)?9Il402dO7~(
zav7|~<MFrF{~=>0?<u!#DYN74>Py?E&4wQ~%j((R<&SgLi9IoF%-P92yu5wnJ!NN0
zS%12yeLx=a;!l}fOKr^dSZV&}rQE;E_Zg`ux8vw9pTp|+$C_7u)<0z&vvoW7DeJ|y
z^X!uRG4DC-_@Z&mlX3PQ-@@?eBi_nS>?z}z9ecbMX8LW+sUPNNt=8WrZK`jSWcw;(
zw>;677{h9F05)Z5{HaeLUf+l2!Cd_LP1x$t^&j&dW88k$a`yQ-k2QX`dk+u4KGpzp
zADc3}{?%{v;q}dTQ1+Ul^>bV0x2&FhC_lN#8z0|h<;JILfVk)8zH)G10IPS7L-JrL
zesYvIw$}M6Ye45f9s4BrDL>n|zMT2>DYv%dffD?@xANHe4zV>q$^Ab3ta%jYzIg_)
z?AY`bzio7UVBe#q?d*OD{umcwt-rgh?62a&oQB!T-v8Qhs~zW=bFS8TX68dz{>fz0
z>HaUSOXA^-DZS<?Lt|U5ff)Oixvy>L(>oX6e17FS`hXucFX!2^uKY1C?}R@Q<Iyp<
zZmTu$)!esz#A{)4KF;r6XH4u%@E<dl$W&biBfs1eTh5%F^SOJU(UE^Xp9ib1@h9(i
z>M|FVPuG9fHq`UZ*(C?+{I{&0-IZS%j@q*BJFNYq&QZ;S8~;cC^I~qx&KiHN`7PJ|
zQ^Z~S$i@Hu{ytcplb`k6b?qz1cel!KSv{L?;;H-H^ZZxa!33MfY|D5j%)6IM`~Ddw
z*eq+#=DnErZv6jT29w9jy&v=98U;JK{~Fn0hMoUFF)yyk53s`Q{SWX~*8Fea%^x>^
IT=E?F3wzkfZ2$lO

literal 0
HcmV?d00001

diff --git a/alacritty_terminal/tests/sixel/testimage_libsixel.sixel b/alacritty_terminal/tests/sixel/testimage_libsixel.sixel
new file mode 100644
index 0000000000..7063a4b0cd
--- /dev/null
+++ b/alacritty_terminal/tests/sixel/testimage_libsixel.sixel
@@ -0,0 +1 @@
+␛Pq"1;1;64;64#0;2;0;0;0#1;2;16;3;0#2;2;25;6;0#3;2;25;9;0#4;2;28;16;0#5;2;28;19;0#6;2;50;19;6#7;2;91;16;0#8;2;91;19;0#9;2;91;22;0#10;2;94;25;0#11;2;94;28;0#12;2;94;31;0#13;2;94;35;0#14;2;94;38;0#15;2;94;41;0#16;2;94;44;0#17;2;94;47;0#18;2;94;50;0#19;2;97;53;0#20;2;97;56;0#21;2;97;60;0#22;2;97;63;0#23;2;63;44;0#24;2;16;0;0#25;2;88;19;0#26;2;88;25;0#27;2;88;28;0#28;2;91;31;0#29;2;88;35;0#30;2;91;38;0#31;2;91;41;0#32;2;91;44;0#33;2;91;50;0#34;2;94;53;0#35;2;91;56;0#36;2;91;60;0#37;2;25;13;0#38;2;16;16;16#39;2;50;50;50#40;2;78;47;41#41;2;82;50;41#42;2;82;53;41#43;2;82;56;41#44;2;82;60;41#45;2;82;63;41#46;2;82;66;41#47;2;82;69;41#48;2;53;53;53#49;2;28;28;28#50;2;66;66;66#51;2;56;56;56#52;2;38;38;38#53;2;6;9;13#54;2;6;6;6#55;2;63;63;63#56;2;3;6;6#57;2;6;13;16#58;2;19;16;13#59;2;35;13;9#60;2;63;25;6#61;2;47;16;9#62;2;28;22;13#63;2;50;25;6#64;2;25;22;13#65;2;85;31;0#66;2;75;28;3#67;2;9;13;16#68;2;41;25;9#69;2;9;16;16#70;2;35;50;63#71;2;72;85;91#72;2;47;47;47#73;2;6;28;41#74;2;97;97;97#75;2;53;69;82#76;2;19;19;13#77;2;94;97;97#78;2;56;38;6#79;2;44;44;44#80;2;19;19;19#81;2;6;22;35#82;2;85;94;97#83;2;6;25;38#84;2;69;44;3#85;2;6;44;69#86;2;47;78;97#87;2;0;60;94#88;2;13;66;97#89;2;88;50;0#90;2;44;28;9#91;2;3;63;97#92;2;41;75;97#93;2;22;22;22#94;2;35;35;35#95;2;31;31;31#0~^NF!56BFN^~$#38?_#24O#25!8O#10??GGG#11!4G#12GGG#13GGG#14!4G#31!6O#17GGGWOOO#33OOO#34!4O#21GGG#22!4GWWWO#37O#38_$#39??_#6G#41!13_#42!8_#43!7_#44!8_#45!8_#46!7_#47!6_#48_$#40???_#7GG#8GGG#9GGWWO#26!4O#27OOO#3!12C#4!19C#5!7C#1C#23G$#1!4?C#2!16C#28!4O#29OOO#30OO#15GGG#16GGG#32OOO#18?GGG#19GG#20!5G#35OOO#36!4O-#50]^^^N!54FN^^^]$#55!4_#38_#53O!52_O#38_#55!4_$#49@#52???O#51G#48!52G#51G#52O#49???@$#56!5?_#54!52O#56_-#51!4o#38}#56~#57!20~^B!8?B^!20~#56~#38}#51!4o$#55!4N#53@#59!21?_??!6@??_#53!21?@#55!4N$#9!27?!10_$#25!27?O!8?O$#38!27?C!8?C$#61!27?G!8?G$#7!28?C!6EC$#8!28?!8W$#58!28?@!6?@$#60!28?A!6?A-#48!4{#38~#56~#57!18~N@#10!12E#57@N!18~#56~#38~#48!4{$#51!4B#60!20?_?@#9!10@#60@?_#51!20?!4B$#62!24?O#6C!5?OO!5?C#59O$#11!25?o!4wW??W!4wo$#26!25?G!5?GG!5?G$#38!25?A!5?__!5?A$#28!30?_??_-#39!4o#38~#56~#57!15~^F!6?_{^^{_!6?B^!15~#56~#38~#39!4o$#48!4N#38!17?_?@#12!6B!4?!6B#38@?_#48!17?!4N$#14!22?!6_!8?!6_$#66!22?O!6?C!4?C!6?O$#62!22?G#13W!4[K!6?K!4[W#62G$#63!23?A!4?_!6?_!4?A$#65!23?C#29!4?O!6?O#65!4?C$#67!29?O!4?O!6?C$#68!29?G!4?G$#60!30?@??@$#64!30?A??A$#69!31?__-#39!4B#38~#56~#57!13~N@!6?w}NB??BN}w!6?@N!13~#56~#38~#39!4B$#72!4{#76!15?O#67A!5?_#31@!8?@#66G!5?G#76O#72!15?!4{$#78!19?_#68C!5?O#60A!8?A#67_!5?A#78_$#16!20?O!5W#65G#62C!8?C#68O!5?C$#17!20?!5_#32_#38??@!6?@#15?!5EC$#66!20?G#15C!5E#69??O!4?O#14??!5@#29A$!21?A#14!5@#70??_?@@?_#16???!5WO$#63!21?@#73!8?C??C#32!4?_#17!5_$#74!30?_{{_#63!8?@$#75!30?G??G$#77!30?O??O$#71!31?AA-#52!4_#80~#56~#57!10~^F!6?o{~~@!6?@~~{o!6?F^!10~#56~#80~#52!4_$#79!4^#67!12?_?@#17A!5B#83???_!6?a#78??@!7?O#79!13?!4^$#76!17?G!7?A#85??S!6?S#38??A#84C!5?C#33_$#78!17?O!7?@#87??G!6?G#17???!5BA#67@?_$#33!17?_#84C!5?C#81???A#71@O??O@#62!4?G#18!5KG#76G$#18!18?G!5K#62G#82!4?AG??GA#89!5?O#19!5O$!18?!5O#89O#86!5?C!4?C#90!5?_#20!5_$!18?!5_#90_#88!5?W!4?W#32!9?@#68A$!18?A#32@#91!9?_!4?_$#74!30?B^^B$#77!30?C__C$#92!30?_??_-#52!4~#80N#56~#57!8~NB!5?_w}!5~o!4?o!5~}w_!5?BN!8~#56~#80N#52!4~$#93!4?o#69!9?O#78G!6?A#67@#69!5?G!4?G!5?@!8?O#93!9?o$#90!14?_#35O!4?_#62O#34@#73!6?C_??_C#78!6?A!6?G#90_$#22!15?!5_#76??C#85!6?AO??OA#33!6?@#20B!4FC#35O$#64!15?C#20C!4FB#87!7?@!4?@#76!6?C#21C!5W#64C$#21!16?!5WC#88!8?@CC@#84!8?G!4?A$!16?A!4?G#91!8?MwwM#62!8?O#89_#22!5_$#68!16?@#92!14?AA#68!14?@$#71!31?@#82@-#52!4@#93~#56~#57!8~!7{!9~}??{!9~!7{!8~#56~#93~#52!4@$#94!4]#64!10?!6A#69A#83!9?@#69__A!9?A#64!6A#94!10?!4]$#95!4_#89!10?@#22!5@#90@#73!10?OO#81@#90!9?@#22!5@#89@#95!10?!4_$#85!31?KK$#91!31?BB-#95FfFFC#38A#54!52A#38A#95CFFfF$#94O?_#72?A?!52C?A#94?_?O$#0_#49WWwx!54wxwWW#0_$#52G#56!4?@#57!52@#56@#52!4?G$#79!5?C!52?C-#0!64N␛\
\ No newline at end of file
diff --git a/alacritty_terminal/tests/sixel/testimage_ppmtosixel.rgba b/alacritty_terminal/tests/sixel/testimage_ppmtosixel.rgba
new file mode 100644
index 0000000000000000000000000000000000000000..902b150d070fa1255aef07d17e7310db0e0af271
GIT binary patch
literal 16384
zcmeI3Z$zb89LFyiG9)teCK6X9GAxM|D-xH)6^Sbnkw_#Gkw_#GiAan~Vhqbz_RYQ-
z`(|0P?3;Nrh8VrMB(h{Vdp@W8yZxTidG0*7``p-S_|Ew~=Q;mA=bYzvpXZ!YCX+Fl
z7rpdBc@C8Nn@p+iPM3oj6I9N|$EY-!F(F;f**qbw*!UP-Z8jNS|7>N9ISA|KBxB-4
zo@#SlbC-UweSqkXfwBgh%;isI4cTy{Ec#*WR#*9qxf-{cu(JJdRj`_}nzov;n!VMv
z?T71yvKDQ)RF>_B>(#Q>ZMcy!@H%bV5bap)TJ2fwTVBg`b5z!`4N=i5rY}N$@TK>a
z3F+LjM`ZipT+6bbD_x8>nQxZABHIt&lw@99SoV9e{cwS7AB0revg4q1QMO%Z`=I2@
z_CqNoZyqp?KYu(jXX|q{>93tRlSunEU5x%dnltxwY~w^lYgf^$V`I?ShlRv~6=voE
zW5c{ZJw1I^f*JOYXJ5?8$;q=6?2P+!<rns1v1qh*cX!S9_V$w!Oqvm!aew#jT}0E<
z)26+>-L$o}Jt@I7Gcyxmh5h*WIHGJeYnoeHO>0NjlM+m@`MmyhXJ@B*-TKD7$@Vrx
z13lfQknIeLdyT3WCfI!5qoX6E)z#J2Q2vA7H<9;i{m#j~M)Jd^S+Nff4<l+Me|L9x
zEW7jrX&TW7j6ZBXuYcW0{>{Gj+iwc_wg`lzc})I;g9D@0NPfOA-1ijUR52n=Bl$He
z_Wu5UMEJ-?_`iH#*WGudd{4%Nq)odIV1mu(-P_wUT8-j=Kh$bU_Pa5ONZTlW&5F%?
zkya!4@oANH16e=#PMEeIl=0WBA)9*Bp8xo?OV&$jP}+VFCfI!Dot+({)d+spODbzc
z_PbkbSx1p;9da+tXF&KhE4KfglQuuT>@sJW1KJwsFer47xHSEs@cX=5TU$meZGL>2
ztPSdrbu#Kg*!rH>Y5GCo*Q_DCyQe3$=f9`7*KxTuQPxG3G#j?QCpP`?wy!6Z=fLq>
zHlKNObJJ+0$<N$&Yr(7sdm8S}R=BYJ`*KYgY4`!**R0qZ8ygWZW~5D{PS$|k8aV6V
zO23V~zE?hRI*r(rkw#l!g3agkuhZf$^mpE_{j>h>X}16V`yFw9I=QB-dix-be|>%3
zXr;yfVYKCT-($-1E3xL<k-h&+6URNBR&2^ji(j*1udS^`lm<UOtFqt2o{v(s=h^uS
zl~(7g*AL40`@E~Gt41pge#cSX=aT&{LiYYBU&eB^c<AbuYwnRo=MlSFze)aTq3~-~
z?3I<3h|=KyJoCz2&)dB_Pbc~4cMbb?A3k4I`h)h9#?Qw!Wrm)cYRvkc@cX>}b-n!f
zs>;5m>~EICT>ss3-<!*un}3b_hb?U-O<ewZ{9qja^769L;yEL&w5Qhamwb!4W<S@{
zAJff|GB<xcyM?#^W9xc8O~1aEpYkYMr>n(=2{z4&y|lCxQ9b<Rb=<O-twR4d@5@yM
z-(21pw}&k}i^H}Yl~>!;A?a!fh2Q60TwF9-_3&>DXU#SH_nz3(?y&Ek(%!f0AMfDH
z7IAW)=bSu#Ib2hRq^l(qe$5)PAIe{8vz%Q}q2FeFp8xN(5cQ3&FI5?GCW3PT5AlO>
z{0j>UM(d&c&hK$vBOpCz+Xg4i?_aMfzK?#u4-&^c8B_9v$|CL|eo*)|EB5^Sd_)iB
zcRtIWRpGpfmOrj7^F=p@dFJIGHsj4b;U^@oE=z3c(&>`e!te9?*AL+*Pvwk`oYg6Z
zLxa(G{pQ1eOt!nn;QttRgbf4tG|R+~@#RvdPWwGOj(=`$&S(t`4AlJl$2hrjNpe1^
z9QyAzw2?99dzX8RI~pDyc5(jrlm5?{=EP-J>jU^<)2!IDv$GM^%J2N1J%{AZWN|J_
ziQh55O`K8Uybkk1__2x8&%flO3|*$!oO!Cn4+_7}%bvJat^BTioJI3Q`#SAB7Y-e|
zXTa`7;PVh`?*81D^!#p8mR~;Cq5hS8eklB!6`S)8TD9`yi#UVl%lCV_J-iDt-aOw3
zJ2dwtk9)oXb=2Yqg<rFV>{|HoLGJ9Kozps`FRJ+`&hWvEA3)fA;|Q-GI{#|R)OCpM
z`&U1&T*vWGO-&iCTKE~4%DGE9e`&)c<HCH08^z6iX*(fhhU%&|&vbs_*R0ruLLs80
z{5+TVGI!S0p0U&+b6VFOvcK;1SNPA@`oEi=GIbqd(+2%+9jc2s;rDqbCnt?oQht1o
zJ7dc^TP1u|TpM&eYh5z_tpDqKaW-Y^y2MW62Zdj=hU}#LpO&-1^TkQ#GJO2j34iE!
zFVqK=9XiuYTSDn|Tpa(z#DvjG%8%a(Dal-vcEOXhzsN(`p*oZJK;hS{*yH2l5hdjp
zhI+#HV=X3)wcR9b5PqN6zkW=9e)FsS?kC|&nkJ4vpU)eu$K;oFzN8HGq!WJ4iaj<q
z7SUt!%e#C%TuJi^zt1~5I%>4|7UQgFTUXDM5=^jZR_t6Z7ZK~>>;ZFL_$dh{*nD2U
z54dJcB(yg8e~yDG#L7GH$jHdE6zuE)xb+v-V4j)S3*c{{m>awc!9O%K^rQtNtgL;7
V{toaZuKM4IzVy#a|2(BR@E_MtKc4^q

literal 0
HcmV?d00001

diff --git a/alacritty_terminal/tests/sixel/testimage_ppmtosixel.sixel b/alacritty_terminal/tests/sixel/testimage_ppmtosixel.sixel
new file mode 100644
index 0000000000..951f602866
--- /dev/null
+++ b/alacritty_terminal/tests/sixel/testimage_ppmtosixel.sixel
@@ -0,0 +1,77 @@
+�0;0;8q"1;1
+#0;2;0;0;0#1;2;49;49;49#2;2;28;28;28#3;2;14;15;16#4;2;12;12;12#5;2;95;38;0#6;2;61;61;61#7;2;100;100;100#8;2;90;33;0#9;2;59;17;8#10;2;53;22;11#11;2;9;9;9#12;2;36;21;12#13;2;52;72;81#14;2;94;29;1#15;2;96;51;0#16;2;96;45;0#17;2;26;24;13#18;2;54;54;54#19;2;98;62;0#20;2;33;33;33#21;2;38;38;38#22;2;66;66;66#23;2;51;51;51#24;2;29;29;29#25;2;93;20;1#26;2;95;36;0#27;2;97;58;0#28;2;93;59;0#29;2;67;31;5#30;2;95;52;1#31;2;44;44;44#32;2;4;6;8#33;2;56;56;56#34;2;35;35;35#35;2;40;40;40#36;2;8;14;17#37;2;52;52;52#38;2;34;23;16#39;2;91;43;0#40;2;31;31;31#41;2;19;18;16#42;2;93;24;1#43;2;93;18;1#44;2;95;40;0#45;2;89;24;1#46;2;95;35;0#47;2;97;56;0#48;2;70;81;87#49;2;83;64;41#50;2;89;22;1#51;2;85;39;2#52;2;82;58;41#53;2;74;28;4#54;2;97;55;0#55;2;29;21;16#56;2;45;45;45#57;2;94;31;0#58;2;57;57;57#59;2;36;36;36#60;2;42;42;42#61;2;80;39;3#62;2;40;21;13#63;2;33;33;33#64;2;87;17;2#65;2;7;13;16#66;2;32;18;13#67;2;13;13;13#68;2;83;62;41#69;2;93;35;0#70;2;62;62;62#71;2;47;47;47#72;2;15;15;15#73;2;59;59;59#74;2;22;22;22#75;2;93;53;1#76;2;94;28;1#77;2;96;50;0#78;2;51;27;14#79;2;64;64;64#80;2;48;48;48#81;2;87;95;100#82;2;27;27;27#83;2;95;33;0#84;2;48;64;60#85;2;60;60;60#86;2;88;55;21#87;2;77;88;95#88;2;90;34;0#89;2;11;14;16#90;2;97;54;0#91;2;96;48;0#92;2;98;65;0#93;2;27;15;14#94;2;53;53;53#95;2;38;38;38#96;2;44;27;16#97;2;93;22;1#98;2;76;46;14#99;2;96;44;0#100;2;94;24;0#101;2;65;65;65#102;2;95;39;0#103;2;98;61;0#104;2;6;11;13#105;2;50;50;50#106;2;29;29;29#107;2;62;62;62#108;2;12;15;16#109;2;100;59;0#110;2;68;30;5#111;2;98;99;100#112;2;43;43;43#113;2;11;16;16#114;2;76;38;4#115;2;94;41;0#116;2;55;55;55#117;2;71;32;5#118;2;34;34;34#119;2;39;39;39#120;2;2;62;100#121;2;3;5;6#122;2;94;26;1#123;2;93;21;1#124;2;96;43;0#125;2;98;65;0#126;2;51;51;51#127;2;98;59;0#128;2;91;44;0#129;2;30;30;30#130;2;83;61;41#131;2;97;57;0#132;2;89;49;21#133;2;65;32;6#134;2;95;33;0#135;2;44;44;44#136;2;56;56;56#137;2;35;35;35#138;2;91;30;1#139;2;41;41;41#140;2;52;18;9#141;2;3;60;97#142;2;67;26;6#143;2;96;41;0#144;2;32;32;32#145;2;79;38;3#146;2;93;62;0#147;2;8;14;17#148;2;36;14;12#149;2;95;37;0#150;2;95;32;0#151;2;22;16;15#152;2;5;42;64#153;2;46;46;46#154;2;13;13;13#155;2;19;50;70#156;2;34;34;34#157;2;82;55;41#158;2;97;53;0#159;2;58;58;58#160;2;42;42;42#161;2;81;68;43#162;2;69;70;61#163;2;89;29;0#164;2;8;14;17#165;2;96;43;0#166;2;100;100;100#167;2;94;98;100#168;2;15;16;16#169;2;14;14;14#170;2;91;47;0#171;2;63;63;63#172;2;94;29;0#173;2;47;47;47#174;2;26;26;26#175;2;68;85;95#176;2;95;34;0#177;2;7;24;35#178;2;60;60;60#179;2;44;44;44#180;2;7;7;7#181;2;91;53;1#182;2;81;50;41#183;2;94;25;1#184;2;96;47;0#185;2;96;42;0#186;2;98;64;0#187;2;53;53;53#188;2;37;37;37#189;2;94;47;0#190;2;66;36;6#191;2;16;17;17#192;2;17;29;32#193;2;65;65;65
+#0!64@$
+#0!64A$
+#0!4C#123C#43!3C#100!6C#172!7C#69!6C#115!6C#189!7C#30!5C#158C#109!6C#92!7C#109C#0!4C$
+#0!3G#43!3G#25!2G#123G#97!2G#42G#183!2G#122G#76!2G#172G#57!2G#150G#83G#176G#46G#26G#149G#5G#102G#44!2G#143G#124G#165G#99G#16!2G#184G#91!2G#77G#15G#158!2G#90!2G#54G#47G#131G#27G#127G#103!2G#19!2G#186G#125G#92!5G#0!3G$
+#0!2O#64!6O#50!4O#45!4O#163!4O#138O#8!3O#88!4O#69!2O#39!5O#128!2O#170!6O#75!4O#181O#75O#181O#28!5O#146!6O#28O#0!2O$
+#0_#76_#162_#182!12_#157!10_#52!7_#130!5_#68!3_#49!8_#120!2_#161!11_#162_#76_#0_$
+-
+#88@#43@#22!60@#43@#88@$
+#48A#101!62A#48A$
+#22C#193!62C#22C$
+#193G#79!4G#136G#18!52G#136G#79!4G#193G$
+#171!4O#21O#11O#180!52O#11O#119O#171!4O$
+#70!4_#169_#121_#104!52_#121_#169_#70!4_$
+-
+#107!4@#4@#32@#147!22@#151@#148!6@#151@#147!22@#32@#4@#107!4@$
+#6!4A#154A#32A#147!22A#9A#43!6A#9A#147!22A#32A#154A#6!4A$
+#85!4C#154C#32C#147!21C#72C#43!8C#72C#147!21C#32C#154C#85!4C$
+#178!4G#154G#32G#147!21G#140G#25!8G#140G#147!21G#32G#154G#178!4G$
+#73!4O#67O#32O#147!21O#64O#123!8O#64O#164O#147!20O#32O#67O#73!4O$
+#159!4_#169_#32_#147!20_#66_#97!10_#66_#147!20_#32_#169_#159!4_$
+-
+#58!4@#169@#32@#147!20@#142@#42!10@#142@#147!20@#32@#169@#58!4@$
+#136!4A#169A#32A#147!19A#72A#183!12A#72A#147!19A#32A#169A#136!4A$
+#33!4C#72C#32C#147!19C#140C#122!12C#140C#147!19C#32C#72C#33!4C$
+#116!4G#72G#32G#147!18G#164G#45G#76!5G#45!2G#76!5G#45G#164G#147!18G#32G#72G#116!4G$
+#18!4O#72O#32O#147!18O#66O#14!6O#10!2O#14!6O#66O#147!18O#32O#72O#18!4O$
+#94!4_#72_#32_#147!18_#142_#57!5_#138_#72!2_#138_#57!5_#142_#147!18_#32_#72_#94!4_$
+-
+#187!4@#168@#32@#147!17@#191@#57@#150!5@#142@#147!2@#142@#150!5@#57@#41@#147!17@#32@#168@#187!4@$
+#37!4A#168A#32A#147!17A#10A#134!6A#93A#147!2A#93A#134!6A#10A#147!17A#32A#168A#37!4A$
+#126!4C#191C#32C#147!16C#164C#8C#46!5C#53C#147!4C#53C#46!5C#8C#164C#147!16C#32C#191C#126!4C$
+#23!4G#191G#32G#147!16G#12G#26!6G#62G#147!4G#62G#26!6G#12G#147!16G#32G#191G#23!4G$
+#105!4O#191O#32O#147!16O#110O#149!5O#88O#89O#147!4O#89O#88O#149!5O#110O#147!16O#32O#191O#105!4O$
+#1!4_#191_#32_#147!15_#41_#5_#102!5_#10_#147!2_#36!2_#147!2_#10_#102!6_#41_#147!15_#32_#191_#1!4_$
+-
+#80!4@#191@#32@#147!15@#10@#44!5@#115@#191@#147!2@#84@#80@#147!2@#191@#115@#44!5@#10@#147!15@#32@#191@#80!4@$
+#173!4A#191A#32A#147!14A#164A#51A#185!5A#133A#147!3A#127A#175A#147!3A#133A#185!5A#51A#89A#147!14A#32A#191A#173!4A$
+#71!4C#191C#32C#147!14C#12C#124!6C#55C#147!2C#192C#111C#7C#192C#147!2C#55C#124!6C#12C#147!14C#32C#191C#71!4C$
+#153!4G#41G#32G#147!14G#117G#99!5G#145G#147!3G#13G#166!2G#13G#147!3G#114G#99!5G#117G#147!14G#32G#41G#153!4G$
+#56!4O#41O#32O#147!13O#41O#99O#16!5O#62O#147!2O#36O#81O#166!2O#167O#127O#147!2O#96O#16!6O#41O#147!13O#32O#41O#56!4O$
+#135!4_#41_#32_#147!13_#78_#184!5_#128_#113_#147!2_#155_#7_#166!2_#7_#155_#147!2_#89_#128_#184!5_#78_#147!13_#32_#41_#135!4_$
+-
+#31!4@#41@#32@#147!12@#89@#128@#91!5@#78@#147!3@#175@#7@#166!2@#7@#190@#147!3@#78@#91!5@#170@#89@#147!12@#32@#41@#31!4@$
+#112!4A#41A#32A#147!12A#12A#77!6A#41A#147!2A#177A#87A#111A#166!2A#111A#87A#177A#147!2A#41A#77!6A#12A#147!12A#32A#41A#112!4A$
+#160!4C#41C#32C#147!12C#114C#15!5C#190C#147!3C#152C#78C#167C#7!2C#167C#78C#152C#147!3C#190C#15!5C#114C#147!12C#32C#41C#160!4C$
+#60!4G#41G#32G#147!11G#41G#158!6G#17G#147!3G#141G#3G#81G#111!2G#81G#36G#141G#147!3G#38G#158!6G#41G#147!11G#32G#41G#60!4G$
+#139!4O#74O#32O#147!11O#190O#90!5O#175O#164O#147!3O#152O#93O#175O#167!2O#82O#93O#152O#147!4O#61O#90!5O#175O#147!11O#32O#74O#139!4O$
+#35!4_#74_#32_#147!10_#89_#181_#54!5_#96_#147!4_#28_#120_#17_#167!2_#17_#120_#177_#147!4_#96_#54!5_#181_#89_#147!10_#32_#74_#35!4_$
+-
+#119!4@#74@#32@#147!10@#96@#47!5@#181@#108@#147!4@#36@#141@#169@#87!2@#169@#141@#36@#147!4@#113@#181@#47!5@#96@#147!10@#32@#74@#119!4@$
+#21!4A#74A#32A#147!10A#114A#27!5A#190A#147!6A#145A#120A#38!2A#120A#152A#147!6A#190A#27!5A#114A#147!10A#32A#74A#21!4A$
+#95!4C#74C#32C#147!9C#41C#127!5C#27C#41C#147!6C#75C#120C#93!2C#120C#185C#147!6C#41C#27C#127!5C#17C#147!9C#32C#74C#95!4C$
+#188!4G#74G#32G#147!9G#190G#103!5G#114G#147!7G#36G#141G#120!2G#141G#36G#147!7G#114G#103!5G#190G#147!9G#32G#74G#188!4G$
+#59!4O#74O#32O#147!8O#113O#28O#19!5O#38O#147!8O#86O#120!2O#132O#147!8O#38O#19!5O#28O#113O#147!8O#32O#74O#59!4O$
+#137!4_#74_#32_#147!8_#96_#186!5_#181_#164_#147!8_#88_#120!2_#138_#147!8_#164_#181_#186!5_#96_#147!8_#32_#74_#137!4_$
+-
+#34!4@#74@#32@#147!8@#98@#92!5@#141@#147!9@#177@#120!2@#177@#147!9@#141@#125!5@#98@#147!8@#32@#74@#34!4@$
+#118!4A#74A#32A#147!7A#164A#17!6A#113A#147!9A#36A#141!2A#36A#147!9A#113A#17!6A#164A#147!7A#32A#74A#118!4A$
+#20!4C#74C#32C#147!25C#29C#110C#147!25C#32C#74C#20!4C$
+#63!4G#74G#32G#147!25G#152!2G#147!25G#32G#74G#63!4G$
+#144!4O#74O#32O#147!25O#124!2O#147!25O#32O#74O#144!4O$
+#40!4_#74_#32_#147!25_#54!2_#147!25_#32_#74_#40!4_$
+-
+#129!4@#82@#121@#65!52@#121@#82@#129!4@$
+#24!4A#71A#168A#11!52A#168A#71A#24!4A$
+#129C#106!3C#129C#160C#179!52C#160C#129C#106!3C#129C$
+#188G#2!62G#188G$
+#153O#82!62O#56O$
+#0_#160_#156_#82_#174!56_#82_#156_#139_#0_$
+-
+#0!64@$
+#0!64A$
+#0!64C$
+#0!64G$
+�
diff --git a/docs/escape_support.md b/docs/escape_support.md
index 4cb6c6f285..5008d6a6e4 100644
--- a/docs/escape_support.md
+++ b/docs/escape_support.md
@@ -102,3 +102,4 @@ brevity.
 | ESCAPE    | STATUS      | NOTE                                               |
 | --------- | ----------- | -------------------------------------------------- |
 | `DCS = s` | IMPLEMENTED |                                                    |
+| `DCS q`   | IMPLEMENTED |                                                    |
diff --git a/docs/features.md b/docs/features.md
index 55f1d91aff..d2b1b7a9b4 100644
--- a/docs/features.md
+++ b/docs/features.md
@@ -78,4 +78,9 @@ file. If an application captures your mouse clicks, which is indicated by a
 change in mouse cursor shape, you're required to hold <kbd>Shift</kbd> to bypass
 that.

+## Graphics with the Sixel protocol
+
+Graphics can be added to the terminal using the Sixel protocol. Every graphic can
+have up to 1024 colors, and it is limited to 4096x4096 pixels.
+
 [configuration file]: ../alacritty.yml

From 50d717f3b1c9b4265941cf1cbae4e87d8a0db02e Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Fri, 2 Apr 2021 00:54:28 +0100
Subject: [PATCH 02/29] Implementation of the XTSMGRAPHICS sequence.

---
 alacritty_terminal/src/ansi.rs           |  4 +++
 alacritty_terminal/src/graphics/sixel.rs |  2 +-
 alacritty_terminal/src/term/mod.rs       | 33 +++++++++++++++++++++++-
 docs/escape_support.md                   |  1 +
 4 files changed, 38 insertions(+), 2 deletions(-)

diff --git a/alacritty_terminal/src/ansi.rs b/alacritty_terminal/src/ansi.rs
index 4051583741..27b9231ed1 100644
--- a/alacritty_terminal/src/ansi.rs
+++ b/alacritty_terminal/src/ansi.rs
@@ -471,6 +471,9 @@ pub trait Handler {
     /// Report text area size in characters.
     fn text_area_size_chars<W: io::Write>(&mut self, _: &mut W) {}

+    /// Report a graphics attribute.
+    fn graphics_attribute<W: io::Write>(&mut self, _: &mut W, _: u16, _: u16) {}
+
     /// Create a parser for Sixel data.
     fn start_sixel_graphic(&mut self, _params: &Params) -> Option<Box<sixel::Parser>> {
         None
@@ -1282,6 +1285,7 @@ where
                 handler.set_scrolling_region(top, bottom);
             },
             ('S', []) => handler.scroll_up(next_param_or(1) as usize),
+            ('S', [b'?']) => handler.graphics_attribute(writer, next_param_or(0), next_param_or(0)),
             ('s', []) => handler.save_cursor_position(),
             ('T', []) => handler.scroll_down(next_param_or(1) as usize),
             ('t', []) => match next_param_or(1) as usize {
diff --git a/alacritty_terminal/src/graphics/sixel.rs b/alacritty_terminal/src/graphics/sixel.rs
index 476089cc9c..221fe7cdbb 100644
--- a/alacritty_terminal/src/graphics/sixel.rs
+++ b/alacritty_terminal/src/graphics/sixel.rs
@@ -33,7 +33,7 @@ use vte::Params;
 struct ColorRegister(u16);

 /// Number of color registers.
-const MAX_COLOR_REGISTERS: usize = 1024;
+pub const MAX_COLOR_REGISTERS: usize = 1024;

 /// Color register for transparent pixels.
 const REG_TRANSPARENT: ColorRegister = ColorRegister(u16::MAX);
diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index ed14fa2f2e..3568f79c2b 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -983,7 +983,7 @@ impl<T: EventListener> Handler for Term<T> {
         match intermediate {
             None => {
                 trace!("Reporting primary device attributes");
-                let _ = writer.write_all(b"\x1b[?4;6c");
+                let _ = writer.write_all(b"\x1b[?6c");
             },
             Some('>') => {
                 trace!("Reporting secondary device attributes");
@@ -1718,6 +1718,37 @@ impl<T: EventListener> Handler for Term<T> {
         let _ = write!(writer, "\x1b[8;{};{}t", self.screen_lines(), self.columns());
     }

+    #[inline]
+    fn graphics_attribute<W: io::Write>(&mut self, writer: &mut W, pi: u16, pa: u16) {
+        // From Xterm documentation:
+        //
+        //   Pi = 1  -> item is number of color registers.
+        //   Pi = 2  -> item is Sixel graphics geometry (in pixels).
+        //
+        //   Pa = 1  -> read attribute.
+        //   Pa = 4  -> read the maximum allowed value.
+        //
+        // Any other request reports an error.
+
+        let (ps, pv) = if pa == 1 || pa == 4 {
+            match pi {
+                1 => (0, &[sixel::MAX_COLOR_REGISTERS][..]),
+                2 => (0, &[MAX_GRAPHIC_DIMENSIONS.0, MAX_GRAPHIC_DIMENSIONS.1][..]),
+                _ => (1, &[][..]), // Report error in Pi
+            }
+        } else {
+            (2, &[][..]) // Report error in Pa
+        };
+
+        let _ = write!(writer, "\x1b[?{};{}", pi, ps);
+
+        for item in pv {
+            let _ = write!(writer, ";{}", item);
+        }
+
+        let _ = write!(writer, "S");
+    }
+
     fn start_sixel_graphic(&mut self, params: &Params) -> Option<Box<sixel::Parser>> {
         let palette = self.graphics.sixel_shared_palette.take();
         Some(Box::new(sixel::Parser::new(params, palette)))
diff --git a/docs/escape_support.md b/docs/escape_support.md
index 5008d6a6e4..bc9517530d 100644
--- a/docs/escape_support.md
+++ b/docs/escape_support.md
@@ -71,6 +71,7 @@ brevity.
 | `CSI SP q` | IMPLEMENTED |                                                   |
 | `CSI r`    | IMPLEMENTED |                                                   |
 | `CSI S`    | IMPLEMENTED |                                                   |
+| `CSI ? S`  | PARTIAL     | Only for reading attributes.                      |
 | `CSI s`    | IMPLEMENTED |                                                   |
 | `CSI T`    | IMPLEMENTED |                                                   |
 | `CSI t`    | PARTIAL     | Only parameters `22` and `23` are supported       |

From c6359f9b136e38648521980670e9362aba6b944d Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Fri, 2 Apr 2021 19:15:38 +0100
Subject: [PATCH 03/29] Don't clear cells after the right side of the graphic.

---
 alacritty_terminal/src/term/mod.rs | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index 3568f79c2b..ef9071e732 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -1794,6 +1794,9 @@ impl<T: EventListener> Handler for Term<T> {

         let left = if scrolling { self.grid.cursor.point.column.0 } else { 0 };

+        let graphic_columns = (graphic.width + self.cell_width - 1) / self.cell_width;
+        let right = min(self.columns(), left + graphic_columns);
+
         let texture = Arc::new(TextureRef {
             id: graphic_id,
             remove_queue: Arc::downgrade(&self.graphics.remove_queue),
@@ -1817,7 +1820,7 @@ impl<T: EventListener> Handler for Term<T> {
             cell.set_graphic(graphic_cell);
             self.grid[line][Column(left)] = cell;

-            for col in left + 1..self.columns() {
+            for col in left + 1..right {
                 self.grid[line][Column(col)] = Cell::default();
             }


From 9723e3f9ebc7699f3e9ec912ad62d586ffe1dafe Mon Sep 17 00:00:00 2001
From: Daniel Brooks <db48x@db48x.net>
Date: Sun, 30 May 2021 23:16:58 -0700
Subject: [PATCH 04/29] =?UTF-8?q?Don=E2=80=99t=20erase=20text=20behind=20a?=
 =?UTF-8?q?=20sixel=20image;=20the=20image=20might=20be=20transparent?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

We still add a reference to the graphic in the first cell of every
line under the image, but we don’t erase any of the text in any of the
cells.
---
 alacritty_terminal/src/term/mod.rs | 13 +++++--------
 1 file changed, 5 insertions(+), 8 deletions(-)

diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index 5ca15b21b3..f08eeb199f 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -1803,13 +1803,14 @@ impl<T: EventListener> Handler for Term<T> {

         // Fill the cells under the graphic.
         //
-        // The cell in the first column contains a reference to the graphic,
-        // with the offset from the start. Rest of the cells are empty.
+        // The cell in the first column contains a reference to the
+        // graphic, with the offset from the start. The rest of the
+        // cells are not overwritten, allowing any text behind
+        // transparent portions of the image to be visible.

         let left = if scrolling { self.grid.cursor.point.column.0 } else { 0 };

         let graphic_columns = (graphic.width + self.cell_width - 1) / self.cell_width;
-        let right = min(self.columns(), left + graphic_columns);

         let texture = Arc::new(TextureRef {
             id: graphic_id,
@@ -1830,14 +1831,10 @@ impl<T: EventListener> Handler for Term<T> {

             // Store a reference to the graphic in the first column.
             let graphic_cell = GraphicCell { texture: texture.clone(), offset_x: 0, offset_y };
-            let mut cell = Cell::default();
+            let mut cell = self.grid[line][Column(left)].clone();
             cell.set_graphic(graphic_cell);
             self.grid[line][Column(left)] = cell;

-            for col in left + 1..right {
-                self.grid[line][Column(col)] = Cell::default();
-            }
-
             if scrolling {
                 self.linefeed();
             }

From 5972714b642efb3f257b77fdf526ebe8492cafd8 Mon Sep 17 00:00:00 2001
From: Daniel Brooks <db48x@db48x.net>
Date: Mon, 31 May 2021 01:26:33 -0700
Subject: [PATCH 05/29] remove an unncessary variable from insert_graphic

---
 alacritty_terminal/src/term/mod.rs | 2 --
 1 file changed, 2 deletions(-)

diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index f08eeb199f..2e1e8bb4c5 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -1810,8 +1810,6 @@ impl<T: EventListener> Handler for Term<T> {

         let left = if scrolling { self.grid.cursor.point.column.0 } else { 0 };

-        let graphic_columns = (graphic.width + self.cell_width - 1) / self.cell_width;
-
         let texture = Arc::new(TextureRef {
             id: graphic_id,
             remove_queue: Arc::downgrade(&self.graphics.remove_queue),

From f4bdc6f038732b0d4e8803f1df9beb9d2da05f47 Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Mon, 31 May 2021 20:50:41 +0100
Subject: [PATCH 06/29] Avoid unnecessary clone when set graphic data.

---
 alacritty_terminal/src/term/mod.rs | 4 +---
 1 file changed, 1 insertion(+), 3 deletions(-)

diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index 5b8a225ae3..d39c5f2ee1 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -1853,9 +1853,7 @@ impl<T: EventListener> Handler for Term<T> {

             // Store a reference to the graphic in the first column.
             let graphic_cell = GraphicCell { texture: texture.clone(), offset_x: 0, offset_y };
-            let mut cell = self.grid[line][Column(left)].clone();
-            cell.set_graphic(graphic_cell);
-            self.grid[line][Column(left)] = cell;
+            self.grid[line][Column(left)].set_graphic(graphic_cell);

             if scrolling {
                 self.linefeed();

From 3caa09ef9b339ebed1329eed016b8a5704bd2c77 Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Mon, 31 May 2021 20:53:23 +0100
Subject: [PATCH 07/29] Define MAX_GRAPHIC_DIMENSIONS as a 2-elements array.

---
 alacritty_terminal/src/graphics/mod.rs   | 2 +-
 alacritty_terminal/src/graphics/sixel.rs | 2 +-
 alacritty_terminal/src/term/mod.rs       | 4 ++--
 3 files changed, 4 insertions(+), 4 deletions(-)

diff --git a/alacritty_terminal/src/graphics/mod.rs b/alacritty_terminal/src/graphics/mod.rs
index 30424c2bea..a285228fa6 100644
--- a/alacritty_terminal/src/graphics/mod.rs
+++ b/alacritty_terminal/src/graphics/mod.rs
@@ -12,7 +12,7 @@ use serde::{Deserialize, Serialize};
 use crate::term::color::Rgb;

 /// Max allowed dimensions (width, height) for the graphic, in pixels.
-pub const MAX_GRAPHIC_DIMENSIONS: (usize, usize) = (4096, 4096);
+pub const MAX_GRAPHIC_DIMENSIONS: [usize; 2] = [4096, 4096];

 /// Unique identifier for every graphic added to a grid.
 #[derive(Serialize, Deserialize, Eq, PartialEq, Clone, Debug, Copy, Hash, PartialOrd, Ord)]
diff --git a/alacritty_terminal/src/graphics/sixel.rs b/alacritty_terminal/src/graphics/sixel.rs
index 221fe7cdbb..d617e53b69 100644
--- a/alacritty_terminal/src/graphics/sixel.rs
+++ b/alacritty_terminal/src/graphics/sixel.rs
@@ -391,7 +391,7 @@ impl Parser {
             return Ok(());
         }

-        if width > MAX_GRAPHIC_DIMENSIONS.0 || height > MAX_GRAPHIC_DIMENSIONS.1 {
+        if width > MAX_GRAPHIC_DIMENSIONS[0] || height > MAX_GRAPHIC_DIMENSIONS[1] {
             return Err(Error::TooBigImage { width, height });
         }

diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index d39c5f2ee1..959f99ef0b 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -1770,7 +1770,7 @@ impl<T: EventListener> Handler for Term<T> {
         let (ps, pv) = if pa == 1 || pa == 4 {
             match pi {
                 1 => (0, &[sixel::MAX_COLOR_REGISTERS][..]),
-                2 => (0, &[MAX_GRAPHIC_DIMENSIONS.0, MAX_GRAPHIC_DIMENSIONS.1][..]),
+                2 => (0, &MAX_GRAPHIC_DIMENSIONS[..]),
                 _ => (1, &[][..]), // Report error in Pi
             }
         } else {
@@ -1800,7 +1800,7 @@ impl<T: EventListener> Handler for Term<T> {
             }
         }

-        if graphic.width > MAX_GRAPHIC_DIMENSIONS.0 || graphic.height > MAX_GRAPHIC_DIMENSIONS.1 {
+        if graphic.width > MAX_GRAPHIC_DIMENSIONS[0] || graphic.height > MAX_GRAPHIC_DIMENSIONS[1] {
             return;
         }


From ae7aa4b5a3ef01a323fa27e0a208d40111b6b11a Mon Sep 17 00:00:00 2001
From: Daniel Brooks <db48x@db48x.net>
Date: Fri, 11 Jun 2021 01:59:17 -0700
Subject: [PATCH 08/29] support DECSET/DECRST (CSI ? Pm h) to change where the
 cursor ends up

after printing a sixel image. The default is for the cursor to be
moved to the first column of the line after the image. When we receive
CSI ? 8452 h, we will instead leave the cursor on the last line of the
image, on the next column past the end of the image.
---
 alacritty_terminal/src/ansi.rs     |  3 +++
 alacritty_terminal/src/term/mod.rs | 20 ++++++++++++++++----
 docs/escape_support.md             |  2 +-
 3 files changed, 20 insertions(+), 5 deletions(-)

diff --git a/alacritty_terminal/src/ansi.rs b/alacritty_terminal/src/ansi.rs
index 14617de166..35763f923f 100644
--- a/alacritty_terminal/src/ansi.rs
+++ b/alacritty_terminal/src/ansi.rs
@@ -569,6 +569,8 @@ pub enum Mode {
     SixelPrivateColorRegisters = 1070,
     /// ?2004
     BracketedPaste = 2004,
+    /// Sixel scrolling leaves cursor to right of graphic.
+    SixelCursorToTheRight = 8452,
 }

 impl Mode {
@@ -600,6 +602,7 @@ impl Mode {
                 1049 => Mode::SwapScreenAndSetRestoreCursor,
                 1070 => Mode::SixelPrivateColorRegisters,
                 2004 => Mode::BracketedPaste,
+                8452 => Mode::SixelCursorToTheRight,
                 _ => {
                     trace!("[unimplemented] primitive mode: {}", num);
                     return None;
diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index 959f99ef0b..7849dd5eb1 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -46,7 +46,7 @@ const TITLE_STACK_MAX_DEPTH: usize = 4096;
 const INITIAL_TABSTOPS: usize = 8;

 bitflags! {
-    pub struct TermMode: u32 {
+    pub struct TermMode: u64 {
         const NONE                = 0;
         const SHOW_CURSOR         = 0b0000_0000_0000_0000_0001;
         const APP_CURSOR          = 0b0000_0000_0000_0000_0010;
@@ -69,7 +69,8 @@ bitflags! {
         const URGENCY_HINTS       = 0b0010_0000_0000_0000_0000;
         const SIXEL_SCROLLING     = 0b0100_0000_0000_0000_0000;
         const SIXEL_PRIV_PALETTE  = 0b1000_0000_0000_0000_0000;
-        const ANY                 = std::u32::MAX;
+        const SIXEL_CURSOR_TO_THE_RIGHT  = 0b0001_0000_0000_0000_0000_0000;
+        const ANY                 = std::u64::MAX;
     }
 }

@@ -1585,6 +1586,9 @@ impl<T: EventListener> Handler for Term<T> {
             ansi::Mode::SixelPrivateColorRegisters => {
                 self.mode.insert(TermMode::SIXEL_PRIV_PALETTE)
             },
+            ansi::Mode::SixelCursorToTheRight => {
+                self.mode.insert(TermMode::SIXEL_CURSOR_TO_THE_RIGHT);
+            },
         }
     }

@@ -1632,6 +1636,9 @@ impl<T: EventListener> Handler for Term<T> {
                 self.graphics.sixel_shared_palette = None;
                 self.mode.remove(TermMode::SIXEL_PRIV_PALETTE);
             },
+            ansi::Mode::SixelCursorToTheRight => {
+                self.mode.remove(TermMode::SIXEL_CURSOR_TO_THE_RIGHT)
+            },
         }
     }

@@ -1855,12 +1862,17 @@ impl<T: EventListener> Handler for Term<T> {
             let graphic_cell = GraphicCell { texture: texture.clone(), offset_x: 0, offset_y };
             self.grid[line][Column(left)].set_graphic(graphic_cell);

-            if scrolling {
+            if scrolling && offset_y < height - self.cell_height as u16 {
                 self.linefeed();
             }
         }

-        if scrolling {
+        if self.mode.contains(TermMode::SIXEL_CURSOR_TO_THE_RIGHT) {
+            let graphic_columns = (graphic.width + self.cell_width - 1) / self.cell_width;
+            let right = min(self.columns(), left + graphic_columns);
+            self.move_forward(Column(right));
+        } else if scrolling {
+            self.linefeed();
             self.carriage_return();
         }
     }
diff --git a/docs/escape_support.md b/docs/escape_support.md
index bc9517530d..4673cedcfb 100644
--- a/docs/escape_support.md
+++ b/docs/escape_support.md
@@ -57,7 +57,7 @@ brevity.
 | `CSI ? h`  | PARTIAL     | Supported modes:                                  |
 |            |             |   `1`, `3`, `6`, `7`, `12`, `25`, `1000`, `1002`  |
 |            |             |   `1004`, `1005`, `1006`, `1007`, `1042`, `1049`  |
-|            |             |   `2004`                                          |
+|            |             |   `2004`, `8452`                                  |
 | `CSI I`    | IMPLEMENTED |                                                   |
 | `CSI J`    | IMPLEMENTED |                                                   |
 | `CSI K`    | IMPLEMENTED |                                                   |

From 573dedd888973c944683c156c42a7fb2cd0b6832 Mon Sep 17 00:00:00 2001
From: Daniel Brooks <db48x@db48x.net>
Date: Sun, 20 Jun 2021 20:22:37 -0700
Subject: [PATCH 09/29] put the TermMode back to just u32; I had miscounted the
 bits

---
 alacritty_terminal/src/term/mod.rs | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index 7849dd5eb1..538801bc18 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -46,7 +46,7 @@ const TITLE_STACK_MAX_DEPTH: usize = 4096;
 const INITIAL_TABSTOPS: usize = 8;

 bitflags! {
-    pub struct TermMode: u64 {
+    pub struct TermMode: u32 {
         const NONE                = 0;
         const SHOW_CURSOR         = 0b0000_0000_0000_0000_0001;
         const APP_CURSOR          = 0b0000_0000_0000_0000_0010;
@@ -70,7 +70,7 @@ bitflags! {
         const SIXEL_SCROLLING     = 0b0100_0000_0000_0000_0000;
         const SIXEL_PRIV_PALETTE  = 0b1000_0000_0000_0000_0000;
         const SIXEL_CURSOR_TO_THE_RIGHT  = 0b0001_0000_0000_0000_0000_0000;
-        const ANY                 = std::u64::MAX;
+        const ANY                 = std::u32::MAX;
     }
 }


From 9d360e4109645bc1c9bd3d0491d8f88cb5fe7647 Mon Sep 17 00:00:00 2001
From: Daniel Brooks <db48x@db48x.net>
Date: Sun, 20 Jun 2021 20:23:05 -0700
Subject: [PATCH 10/29] move_forward takes a relative column count, not an
 absolute column number

---
 alacritty_terminal/src/term/mod.rs | 3 +--
 1 file changed, 1 insertion(+), 2 deletions(-)

diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index 538801bc18..94b3a50c3c 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -1869,8 +1869,7 @@ impl<T: EventListener> Handler for Term<T> {

         if self.mode.contains(TermMode::SIXEL_CURSOR_TO_THE_RIGHT) {
             let graphic_columns = (graphic.width + self.cell_width - 1) / self.cell_width;
-            let right = min(self.columns(), left + graphic_columns);
-            self.move_forward(Column(right));
+            self.move_forward(Column(graphic_columns));
         } else if scrolling {
             self.linefeed();
             self.carriage_return();

From ebf41d5fb035232bc504c568f4e1329a10292848 Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Fri, 24 Sep 2021 03:35:07 +0100
Subject: [PATCH 11/29] Interprets mode 80 as Sixel Display Mode.

This is reverse of the *sixel scrolling* option, which should match the actual
behaviour of DEC terminals.

For reference: https://github.com/alacritty/alacritty/pull/4763#issuecomment-925374707
---
 alacritty_terminal/src/ansi.rs     |  4 ++--
 alacritty_terminal/src/term/mod.rs | 11 +++++------
 2 files changed, 7 insertions(+), 8 deletions(-)

diff --git a/alacritty_terminal/src/ansi.rs b/alacritty_terminal/src/ansi.rs
index 35763f923f..3fc3f2ba9e 100644
--- a/alacritty_terminal/src/ansi.rs
+++ b/alacritty_terminal/src/ansi.rs
@@ -546,7 +546,7 @@ pub enum Mode {
     /// ?25
     ShowCursor = 25,
     /// ?80
-    SixelScrolling = 80,
+    SixelDisplay = 80,
     /// ?1000
     ReportMouseClicks = 1000,
     /// ?1002
@@ -590,7 +590,7 @@ impl Mode {
                 7 => Mode::LineWrap,
                 12 => Mode::BlinkingCursor,
                 25 => Mode::ShowCursor,
-                80 => Mode::SixelScrolling,
+                80 => Mode::SixelDisplay,
                 1000 => Mode::ReportMouseClicks,
                 1002 => Mode::ReportCellMouseMotion,
                 1003 => Mode::ReportAllMouseMotion,
diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index 451663f7eb..ccf5ce58c6 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -67,7 +67,7 @@ bitflags! {
         const ALTERNATE_SCROLL    = 0b0000_1000_0000_0000_0000;
         const VI                  = 0b0001_0000_0000_0000_0000;
         const URGENCY_HINTS       = 0b0010_0000_0000_0000_0000;
-        const SIXEL_SCROLLING     = 0b0100_0000_0000_0000_0000;
+        const SIXEL_DISPLAY       = 0b0100_0000_0000_0000_0000;
         const SIXEL_PRIV_PALETTE  = 0b1000_0000_0000_0000_0000;
         const SIXEL_CURSOR_TO_THE_RIGHT  = 0b0001_0000_0000_0000_0000_0000;
         const ANY                 = std::u32::MAX;
@@ -80,7 +80,6 @@ impl Default for TermMode {
             | TermMode::LINE_WRAP
             | TermMode::ALTERNATE_SCROLL
             | TermMode::URGENCY_HINTS
-            | TermMode::SIXEL_SCROLLING
             | TermMode::SIXEL_PRIV_PALETTE
     }
 }
@@ -1598,7 +1597,7 @@ impl<T: EventListener> Handler for Term<T> {
                 style.blinking = true;
                 self.event_proxy.send_event(Event::CursorBlinkingChange(true));
             },
-            ansi::Mode::SixelScrolling => self.mode.insert(TermMode::SIXEL_SCROLLING),
+            ansi::Mode::SixelDisplay => self.mode.insert(TermMode::SIXEL_DISPLAY),
             ansi::Mode::SixelPrivateColorRegisters => {
                 self.mode.insert(TermMode::SIXEL_PRIV_PALETTE)
             },
@@ -1647,7 +1646,7 @@ impl<T: EventListener> Handler for Term<T> {
                 style.blinking = false;
                 self.event_proxy.send_event(Event::CursorBlinkingChange(false));
             },
-            ansi::Mode::SixelScrolling => self.mode.remove(TermMode::SIXEL_SCROLLING),
+            ansi::Mode::SixelDisplay => self.mode.remove(TermMode::SIXEL_DISPLAY),
             ansi::Mode::SixelPrivateColorRegisters => {
                 self.graphics.sixel_shared_palette = None;
                 self.mode.remove(TermMode::SIXEL_PRIV_PALETTE);
@@ -1838,7 +1837,7 @@ impl<T: EventListener> Handler for Term<T> {
         let graphic_id = self.graphics.next_id();
         self.graphics.pending.push(GraphicData { id: graphic_id, ..graphic });

-        // If SIXEL_SCROLLING is enabled, the start of the graphic is the
+        // If SIXEL_DISPLAY is disabled, the start of the graphic is the
         // cursor position, and the grid can be scrolled if the graphic is
         // larger than the screen. The cursor is moved to the next line
         // after the graphic.
@@ -1846,7 +1845,7 @@ impl<T: EventListener> Handler for Term<T> {
         // If it is disabled, the graphic starts at (0, 0), the grid is never
         // scrolled, and the cursor position is unmodified.

-        let scrolling = self.mode.contains(TermMode::SIXEL_SCROLLING);
+        let scrolling = !self.mode.contains(TermMode::SIXEL_DISPLAY);

         // Fill the cells under the graphic.
         //

From 48b2610a7ac8c1ea22d6d1fff5208966e5efa574 Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Tue, 12 Jul 2022 13:38:05 +0100
Subject: [PATCH 12/29] Fill all cells under a graphic with the template.

With the template we can create hyperlinks attached to the graphic.

To avoid reflow issues when a row is shrank, wrapped rows that only contain
graphic cells are discarded. With this approach we loss some info, like the
hyperlink, but the image is always properly positioned in the grid.
---
 alacritty/src/renderer/graphics/draw.rs | 29 ++++++++++++++-----------
 alacritty/src/renderer/rects.rs         |  4 ++++
 alacritty_terminal/src/grid/row.rs      |  4 ++--
 alacritty_terminal/src/term/mod.rs      | 10 ++++++---
 4 files changed, 29 insertions(+), 18 deletions(-)

diff --git a/alacritty/src/renderer/graphics/draw.rs b/alacritty/src/renderer/graphics/draw.rs
index 0bc4b3ec23..cb61562fe8 100644
--- a/alacritty/src/renderer/graphics/draw.rs
+++ b/alacritty/src/renderer/graphics/draw.rs
@@ -39,21 +39,24 @@ impl RenderList {
     /// The graphic is added only the first time it is found in a cell.
     #[inline]
     pub fn update(&mut self, cell: &RenderableCell) {
-        if let Some(graphic) = cell.extra.as_ref().and_then(|cell| cell.graphic.as_ref()) {
-            let graphic_id = graphic.graphic_id();
-            if self.items.contains_key(&graphic_id) {
-                return;
-            }
+        let graphic = match cell.extra.as_ref().and_then(|cell| cell.graphic.as_ref()) {
+            Some(graphic) => graphic,
+            _ => return,
+        };
+
+        let graphic_id = graphic.graphic_id();
+        if self.items.contains_key(&graphic_id) {
+            return;
+        }

-            let render_item = RenderPosition {
-                column: cell.point.column,
-                line: cell.point.line,
-                offset_x: graphic.offset_x,
-                offset_y: graphic.offset_y,
-            };
+        let render_item = RenderPosition {
+            column: cell.point.column,
+            line: cell.point.line,
+            offset_x: graphic.offset_x,
+            offset_y: graphic.offset_y,
+        };

-            self.items.insert(graphic_id, render_item);
-        }
+        self.items.insert(graphic_id, render_item);
     }

     /// Returns `true` if there are no items to render.
diff --git a/alacritty/src/renderer/rects.rs b/alacritty/src/renderer/rects.rs
index 73ca2c94a5..113eaab59b 100644
--- a/alacritty/src/renderer/rects.rs
+++ b/alacritty/src/renderer/rects.rs
@@ -179,6 +179,10 @@ impl RenderLines {
     /// Update the stored lines with the next cell info.
     #[inline]
     pub fn update(&mut self, cell: &RenderableCell) {
+        if cell.flags.contains(Flags::GRAPHICS) {
+            return;
+        }
+
         self.update_flag(cell, Flags::UNDERLINE);
         self.update_flag(cell, Flags::DOUBLE_UNDERLINE);
         self.update_flag(cell, Flags::STRIKEOUT);
diff --git a/alacritty_terminal/src/grid/row.rs b/alacritty_terminal/src/grid/row.rs
index 900d2a76cf..f1bb6adb5c 100644
--- a/alacritty_terminal/src/grid/row.rs
+++ b/alacritty_terminal/src/grid/row.rs
@@ -8,7 +8,7 @@ use serde::{Deserialize, Serialize};

 use crate::grid::GridCell;
 use crate::index::Column;
-use crate::term::cell::ResetDiscriminant;
+use crate::term::cell::{Flags, ResetDiscriminant};

 /// A row in the grid.
 #[derive(Serialize, Deserialize, Default, Clone, Debug)]
@@ -81,7 +81,7 @@ impl<T: Clone + Default> Row<T> {

         self.occ = min(self.occ, columns);

-        if new_row.is_empty() {
+        if new_row.is_empty() || new_row.iter().all(|cell| cell.flags().contains(Flags::GRAPHICS)) {
             None
         } else {
             Some(new_row)
diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index 3ef6b2d622..96ed56781d 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -2074,7 +2074,7 @@ impl<T: EventListener> Handler for Term<T> {
         // cells are not overwritten, allowing any text behind
         // transparent portions of the image to be visible.

-        let left = if scrolling { self.grid.cursor.point.column.0 } else { 0 };
+        let leftmost = if scrolling { self.grid.cursor.point.column.0 } else { 0 };

         let texture = Arc::new(TextureRef {
             id: graphic_id,
@@ -2094,8 +2094,12 @@ impl<T: EventListener> Handler for Term<T> {
             };

             // Store a reference to the graphic in the first column.
-            let graphic_cell = GraphicCell { texture: texture.clone(), offset_x: 0, offset_y };
-            self.grid[line][Column(left)].set_graphic(graphic_cell);
+            for (left, offset_x) in (leftmost..).zip((0..width).step_by(cell_width)) {
+                let graphic_cell = GraphicCell { texture: texture.clone(), offset_x, offset_y };
+                let mut cell = self.grid.cursor.template.clone();
+                cell.set_graphic(graphic_cell);
+                self.grid[line][Column(left)] = cell;
+            }

             if scrolling && offset_y < height - cell_height as u16 {
                 self.linefeed();

From 44695990fc5f4d6e6f64f998b51a41483eba3388 Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Tue, 12 Jul 2022 13:55:28 +0100
Subject: [PATCH 13/29] Allow hue values up to 360 in the Sixel parser.

---
 alacritty_terminal/src/graphics/sixel.rs | 10 +++++++---
 1 file changed, 7 insertions(+), 3 deletions(-)

diff --git a/alacritty_terminal/src/graphics/sixel.rs b/alacritty_terminal/src/graphics/sixel.rs
index 6314873b4d..c243501bbf 100644
--- a/alacritty_terminal/src/graphics/sixel.rs
+++ b/alacritty_terminal/src/graphics/sixel.rs
@@ -172,9 +172,9 @@ impl CommandParser {

                 if self.params_position >= 4 {
                     macro_rules! p {
-                        ($index:expr) => {
+                        ($index:expr, $limit:expr) => {
                             match self.params[$index] {
-                                x if x <= 100 => x,
+                                x if x <= $limit => x,
                                 x => {
                                     return Err(Error::InvalidColorComponent {
                                         register: register.0,
@@ -183,11 +183,15 @@ impl CommandParser {
                                 },
                             }
                         };
+
+                        ($index:expr) => {
+                            p!($index, 100)
+                        };
                     }

                     let (r, g, b) = match self.params[1] {
                         // HLS.
-                        1 => hls_to_rgb(p!(2), p!(3), p!(4)),
+                        1 => hls_to_rgb(p!(2, 360), p!(3), p!(4)),

                         // RGB.
                         2 => (p!(2), p!(3), p!(4)),

From b73717649bbc61cc9a3f62b530d724cf9731dc10 Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Tue, 12 Jul 2022 19:02:22 +0100
Subject: [PATCH 14/29] Allow replacing part of a graphic with text.

When text is added to a cell with a reference to a graphic, an operation is sent
to the OpenGL thread to replace a subregion of the cell with a transparent area.

If the OpenGL driver supports the GL_ARB_clear_texture extension, the region is
updated with glClearTexSubImage. If the extension is not available, the
texture is updated with glTexSubImage2D.
---
 alacritty/build.rs                      |   3 +-
 alacritty/src/display/content.rs        |  25 +++-
 alacritty/src/display/mod.rs            |   8 +-
 alacritty/src/renderer/graphics/draw.rs |   5 +-
 alacritty/src/renderer/graphics/mod.rs  | 153 ++++++++++++++++++++++--
 alacritty/src/renderer/mod.rs           |  11 +-
 alacritty_terminal/src/graphics/mod.rs  |  97 ++++++++++++---
 alacritty_terminal/src/grid/mod.rs      |   8 +-
 alacritty_terminal/src/term/mod.rs      |  19 ++-
 9 files changed, 287 insertions(+), 42 deletions(-)

diff --git a/alacritty/build.rs b/alacritty/build.rs
index 0874f88c03..e8cf8e3b11 100644
--- a/alacritty/build.rs
+++ b/alacritty/build.rs
@@ -15,7 +15,8 @@ fn main() {
     let dest = env::var("OUT_DIR").unwrap();
     let mut file = File::create(&Path::new(&dest).join("gl_bindings.rs")).unwrap();

-    Registry::new(Api::Gl, (3, 3), Profile::Core, Fallbacks::All, ["GL_ARB_blend_func_extended"])
+    let extensions = ["GL_ARB_blend_func_extended", "GL_ARB_clear_texture"];
+    Registry::new(Api::Gl, (3, 3), Profile::Core, Fallbacks::All, extensions)
         .write_bindings(GlobalGenerator, &mut file)
         .unwrap();

diff --git a/alacritty/src/display/content.rs b/alacritty/src/display/content.rs
index 11753c1794..9e179009d8 100644
--- a/alacritty/src/display/content.rs
+++ b/alacritty/src/display/content.rs
@@ -4,7 +4,7 @@ use std::{cmp, mem};

 use alacritty_terminal::ansi::{Color, CursorShape, NamedColor};
 use alacritty_terminal::event::EventListener;
-use alacritty_terminal::graphics::GraphicCell;
+use alacritty_terminal::graphics::GraphicId;
 use alacritty_terminal::grid::Indexed;
 use alacritty_terminal::index::{Column, Line, Point};
 use alacritty_terminal::selection::SelectionRange;
@@ -190,13 +190,26 @@ pub struct RenderableCell {
     pub extra: Option<Box<RenderableCellExtra>>,
 }

+/// Graphic data stored in a single cell.
+#[derive(Clone, Debug)]
+pub struct RenderableGraphicCell {
+    /// Texture to draw the graphic in this cell.
+    pub id: GraphicId,
+
+    /// Offset in the x direction.
+    pub offset_x: u16,
+
+    /// Offset in the y direction.
+    pub offset_y: u16,
+}
+
 /// Extra storage with rarely present fields for [`RenderableCell`], to reduce the cell size we
 /// pass around.
 #[derive(Clone, Debug)]
 pub struct RenderableCellExtra {
     pub zerowidth: Option<Vec<char>>,
     pub hyperlink: Option<Hyperlink>,
-    pub graphic: Option<GraphicCell>,
+    pub graphic: Option<RenderableGraphicCell>,
 }

 impl RenderableCell {
@@ -269,11 +282,17 @@ impl RenderableCell {
         let zerowidth = cell.zerowidth();
         let hyperlink = cell.hyperlink();

+        let graphic = cell.graphic().map(|graphic| RenderableGraphicCell {
+            id: graphic.texture.id,
+            offset_x: graphic.offset_x,
+            offset_y: graphic.offset_y,
+        });
+
         let extra = (zerowidth.is_some() || hyperlink.is_some()).then(|| {
             Box::new(RenderableCellExtra {
                 zerowidth: zerowidth.map(|zerowidth| zerowidth.to_vec()),
                 hyperlink,
-                graphic: cell.graphic().cloned(),
+                graphic,
             })
         });

diff --git a/alacritty/src/display/mod.rs b/alacritty/src/display/mod.rs
index 9e7d738d12..c87cc124ea 100644
--- a/alacritty/src/display/mod.rs
+++ b/alacritty/src/display/mod.rs
@@ -293,13 +293,13 @@ impl TermDimensions for SizeInfo {
     }

     #[inline]
-    fn cell_height(&self) -> Option<usize> {
-        Some(self.cell_height() as usize)
+    fn cell_height(&self) -> f32 {
+        self.cell_height()
     }

     #[inline]
-    fn cell_width(&self) -> Option<usize> {
-        Some(self.cell_width() as usize)
+    fn cell_width(&self) -> f32 {
+        self.cell_width()
     }
 }

diff --git a/alacritty/src/renderer/graphics/draw.rs b/alacritty/src/renderer/graphics/draw.rs
index cb61562fe8..3d0a87e148 100644
--- a/alacritty/src/renderer/graphics/draw.rs
+++ b/alacritty/src/renderer/graphics/draw.rs
@@ -44,8 +44,7 @@ impl RenderList {
             _ => return,
         };

-        let graphic_id = graphic.graphic_id();
-        if self.items.contains_key(&graphic_id) {
+        if self.items.contains_key(&graphic.id) {
             return;
         }

@@ -56,7 +55,7 @@ impl RenderList {
             offset_y: graphic.offset_y,
         };

-        self.items.insert(graphic_id, render_item);
+        self.items.insert(graphic.id, render_item);
     }

     /// Returns `true` if there are no items to render.
diff --git a/alacritty/src/renderer/graphics/mod.rs b/alacritty/src/renderer/graphics/mod.rs
index e84396c06f..797a37112c 100644
--- a/alacritty/src/renderer/graphics/mod.rs
+++ b/alacritty/src/renderer/graphics/mod.rs
@@ -3,7 +3,9 @@
 use std::mem;

 use crate::display::SizeInfo;
-use alacritty_terminal::graphics::{ColorType, GraphicData, GraphicId, UpdateQueues};
+use alacritty_terminal::graphics::{
+    ClearSubregion, ColorType, GraphicData, GraphicId, UpdateQueues,
+};

 use log::trace;
 use serde::{Deserialize, Serialize};
@@ -11,13 +13,23 @@ use serde::{Deserialize, Serialize};
 use crate::gl::types::*;
 use crate::{gl, renderer};

-use std::collections::HashMap;
+use std::cmp;
+use std::collections::{HashMap, HashSet};
+use std::ffi::CStr;

 mod draw;
 mod shader;

 pub use draw::RenderList;

+bitflags::bitflags! {
+    /// Result of the `run_updates` operation.
+    pub struct UpdateResult: u8 {
+        const SUCCESS = 1 << 0;
+        const NEED_RESET_ACTIVE_TEX = 1 << 1;
+    }
+}
+
 /// Type for texture names generated in the GPU.
 #[derive(Serialize, Deserialize, Eq, PartialEq, Clone, Debug)]
 pub struct TextureName(GLuint);
@@ -44,6 +56,9 @@ pub struct GraphicTexture {
     /// Used to scale it if the user increases or decreases the font size.
     cell_height: f32,

+    /// Cell width at the moment graphic was created.
+    cell_width: f32,
+
     /// Width in pixels of the graphic.
     width: u16,

@@ -58,23 +73,32 @@ pub struct GraphicsRenderer {

     /// Collection to associate graphic identifiers with their textures.
     graphic_textures: HashMap<GraphicId, GraphicTexture>,
+
+    /// Indicate if the OpenGL driver has the `clear_texture` extension.
+    clear_texture_ext: bool,
 }

 impl GraphicsRenderer {
     pub fn new() -> Result<GraphicsRenderer, renderer::Error> {
         let program = shader::GraphicsShaderProgram::new()?;
-        Ok(GraphicsRenderer { program, graphic_textures: HashMap::default() })
+        let clear_texture_ext = check_opengl_extensions(&["GL_ARB_clear_texture"]);
+        Ok(GraphicsRenderer { program, graphic_textures: HashMap::default(), clear_texture_ext })
     }

     /// Run the required actions to apply changes for the graphics in the grid.
     #[inline]
-    pub fn run_updates(&mut self, update_queues: UpdateQueues, size_info: &SizeInfo) {
-        self.remove_graphics(update_queues.remove_queue);
-        self.upload_pending_graphics(update_queues.pending, size_info);
+    pub fn run_updates(
+        &mut self,
+        update_queues: UpdateQueues,
+        size_info: &SizeInfo,
+    ) -> UpdateResult {
+        self.remove_graphics(update_queues.remove_queue)
+            | self.upload_pending_graphics(update_queues.pending, size_info)
+            | self.clear_subregions(update_queues.clear_subregions)
     }

     /// Release resources used by removed graphics.
-    fn remove_graphics(&mut self, removed_ids: Vec<GraphicId>) {
+    fn remove_graphics(&mut self, removed_ids: Vec<GraphicId>) -> UpdateResult {
         let mut textures = Vec::with_capacity(removed_ids.len());
         for id in removed_ids {
             if let Some(mut graphic_texture) = self.graphic_textures.remove(&id) {
@@ -89,10 +113,22 @@ impl GraphicsRenderer {
         unsafe {
             gl::DeleteTextures(textures.len() as GLint, textures.as_ptr());
         }
+
+        UpdateResult::SUCCESS
     }

     /// Create new textures in the GPU, and upload the pixels to them.
-    fn upload_pending_graphics(&mut self, graphics: Vec<GraphicData>, size_info: &SizeInfo) {
+    fn upload_pending_graphics(
+        &mut self,
+        graphics: Vec<GraphicData>,
+        size_info: &SizeInfo,
+    ) -> UpdateResult {
+        let result = if graphics.is_empty() {
+            UpdateResult::SUCCESS
+        } else {
+            UpdateResult::NEED_RESET_ACTIVE_TEX
+        };
+
         for graphic in graphics {
             let mut texture = 0;

@@ -130,12 +166,84 @@ impl GraphicsRenderer {
             let graphic_texture = GraphicTexture {
                 texture: TextureName(texture),
                 cell_height: size_info.cell_height(),
+                cell_width: size_info.cell_width(),
                 width: graphic.width as u16,
                 height: graphic.height as u16,
             };

             self.graphic_textures.insert(graphic.id, graphic_texture);
         }
+
+        result
+    }
+
+    /// Update textures in the GPU to clear specific subregions.
+    pub fn clear_subregions(&mut self, clear_subregions: Vec<ClearSubregion>) -> UpdateResult {
+        // If the GL_ARB_clear_texture extension is available we can use
+        // glClearTexSubImage to clear the region without sending any memory.
+        //
+        // If the extension is not available, we have to initialize empty memory
+        // and upload it with glTexSubImage2D.
+
+        let mut result = UpdateResult::SUCCESS;
+
+        for clear_subregion in clear_subregions {
+            let entry = match self.graphic_textures.get(&clear_subregion.id) {
+                Some(entry) => entry,
+                None => continue,
+            };
+
+            let x_offset = clear_subregion.x as GLint;
+            let y_offset = clear_subregion.y as GLint;
+
+            let max_width = entry.width as GLint - x_offset;
+            let max_height = entry.height as GLint - y_offset;
+
+            let width = cmp::min(entry.cell_width as GLint, max_width);
+            let height = cmp::min(entry.cell_height as GLint, max_height);
+
+            if self.clear_texture_ext {
+                let empty = [0_u8; 4];
+
+                unsafe {
+                    gl::ClearTexSubImage(
+                        entry.texture.0,
+                        0,
+                        x_offset,
+                        y_offset,
+                        0,
+                        width,
+                        height,
+                        1,
+                        gl::RGBA,
+                        gl::UNSIGNED_BYTE,
+                        empty.as_ptr().cast(),
+                    );
+                }
+            } else {
+                let buf_size = width * height * 4;
+                let empty = vec![0_u8; buf_size as usize];
+
+                unsafe {
+                    gl::BindTexture(gl::TEXTURE_2D, entry.texture.0);
+                    gl::TexSubImage2D(
+                        gl::TEXTURE_2D,
+                        0,
+                        x_offset,
+                        y_offset,
+                        width,
+                        height,
+                        gl::RGBA,
+                        gl::UNSIGNED_BYTE,
+                        empty.as_ptr().cast(),
+                    )
+                }
+
+                result = UpdateResult::NEED_RESET_ACTIVE_TEX;
+            }
+        }
+
+        result
     }

     /// Draw graphics in the display.
@@ -146,3 +254,32 @@ impl GraphicsRenderer {
         }
     }
 }
+
+fn check_opengl_extensions(extensions: &[&str]) -> bool {
+    // Use a HashSet to track extensions needed to be found. When the set is
+    // empty, we know that all extensions are available.
+    let mut needed: HashSet<_> = extensions.iter().collect();
+
+    let mut num_exts = 0;
+    unsafe {
+        gl::GetIntegerv(gl::NUM_EXTENSIONS, &mut num_exts);
+    }
+
+    for index in 0..num_exts as GLuint {
+        let pointer = unsafe { gl::GetStringi(gl::EXTENSIONS, index) };
+        if pointer.is_null() {
+            log::warn!("Can't get OpenGL extension name at index {} of {}", index, num_exts);
+            return false;
+        }
+
+        let extension = unsafe { CStr::from_ptr(pointer.cast()) };
+        if let Ok(ext) = extension.to_str() {
+            if needed.remove(&ext) && needed.is_empty() {
+                return true;
+            }
+        }
+    }
+
+    log::debug!("Missing OpenGL extensions: {:?}", needed);
+    false
+}
diff --git a/alacritty/src/renderer/mod.rs b/alacritty/src/renderer/mod.rs
index 89a1673048..8d1058ff4f 100644
--- a/alacritty/src/renderer/mod.rs
+++ b/alacritty/src/renderer/mod.rs
@@ -229,7 +229,11 @@ impl Renderer {
     #[inline]
     pub fn graphics_run_updates(&mut self, update_queues: UpdateQueues, size_info: &SizeInfo) {
         if let Some(graphics_renderer) = self.graphics_renderer.as_mut() {
-            graphics_renderer.run_updates(update_queues, size_info);
+            let result = graphics_renderer.run_updates(update_queues, size_info);
+
+            if result.contains(graphics::UpdateResult::NEED_RESET_ACTIVE_TEX) {
+                self.reset_active_tex();
+            }
         }
     }

@@ -240,6 +244,11 @@ impl Renderer {
             graphics_renderer.draw(render_list, size_info);
         }

+        self.reset_active_tex();
+    }
+
+    /// Reset the cached value of the active texture.
+    pub fn reset_active_tex(&mut self) {
         match &mut self.text_renderer {
             TextRendererProvider::Gles2(renderer) => renderer.reset_active_tex(),
             TextRendererProvider::Glsl3(renderer) => renderer.reset_active_tex(),
diff --git a/alacritty_terminal/src/graphics/mod.rs b/alacritty_terminal/src/graphics/mod.rs
index 109b3344ed..846d866c95 100644
--- a/alacritty_terminal/src/graphics/mod.rs
+++ b/alacritty_terminal/src/graphics/mod.rs
@@ -29,12 +29,12 @@ pub struct TextureRef {
     pub id: GraphicId,

     /// Queue to track removed references.
-    pub remove_queue: Weak<Mutex<Vec<GraphicId>>>,
+    pub texture_operations: Weak<Mutex<Vec<TextureOperation>>>,
 }

 impl PartialEq for TextureRef {
     fn eq(&self, t: &Self) -> bool {
-        // Ignore remove_queue.
+        // Ignore texture_operations.
         self.id == t.id
     }
 }
@@ -43,14 +43,14 @@ impl Eq for TextureRef {}

 impl Drop for TextureRef {
     fn drop(&mut self) {
-        if let Some(remove_queue) = self.remove_queue.upgrade() {
-            remove_queue.lock().push(self.id);
+        if let Some(texture_operations) = self.texture_operations.upgrade() {
+            texture_operations.lock().push(TextureOperation::Remove(self.id));
         }
     }
 }

 /// Graphic data stored in a single cell.
-#[derive(Eq, PartialEq, Clone, Debug)]
+#[derive(Clone, Debug)]
 pub struct GraphicCell {
     /// Texture to draw the graphic in this cell.
     pub texture: Arc<TextureRef>,
@@ -60,6 +60,32 @@ pub struct GraphicCell {

     /// Offset in the y direction.
     pub offset_y: u16,
+
+    /// Queue to track empty subregions.
+    pub texture_operations: Weak<Mutex<Vec<TextureOperation>>>,
+}
+
+impl PartialEq for GraphicCell {
+    fn eq(&self, c: &Self) -> bool {
+        // Ignore texture_operations.
+        self.texture == c.texture && self.offset_x == c.offset_x && self.offset_y == c.offset_y
+    }
+}
+
+impl Eq for GraphicCell {}
+
+impl Drop for GraphicCell {
+    fn drop(&mut self) {
+        if let Some(texture_operations) = self.texture_operations.upgrade() {
+            let tex_op = TextureOperation::ClearSubregion(ClearSubregion {
+                id: self.texture.id,
+                x: self.offset_x,
+                y: self.offset_y,
+            });
+
+            texture_operations.lock().push(tex_op);
+        }
+    }
 }

 impl GraphicCell {
@@ -99,13 +125,40 @@ pub struct GraphicData {
     pub pixels: Vec<u8>,
 }

+/// Operation to clear a subregion in an existing graphic.
+#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
+pub struct ClearSubregion {
+    /// Graphics identifier.
+    pub id: GraphicId,
+
+    /// X coordinate.
+    pub x: u16,
+
+    /// Y coordinate.
+    pub y: u16,
+}
+
 /// Queues to add or to remove the textures in the display.
+#[derive(Default)]
 pub struct UpdateQueues {
     /// Graphics read from the PTY.
     pub pending: Vec<GraphicData>,

     /// Graphics removed from the grid.
     pub remove_queue: Vec<GraphicId>,
+
+    /// Subregions in a graphic to be clear.
+    pub clear_subregions: Vec<ClearSubregion>,
+}
+
+/// Operations on the existing textures.
+#[derive(Debug)]
+pub enum TextureOperation {
+    /// Remove a texture from the GPU.
+    Remove(GraphicId),
+
+    /// Clear a subregion.
+    ClearSubregion(ClearSubregion),
 }

 /// Track changes in the grid to add or to remove graphics.
@@ -118,16 +171,16 @@ pub struct Graphics {
     pub pending: Vec<GraphicData>,

     /// Graphics removed from the grid.
-    pub remove_queue: Arc<Mutex<Vec<GraphicId>>>,
+    pub texture_operations: Arc<Mutex<Vec<TextureOperation>>>,

     /// Shared palette for Sixel graphics.
     pub sixel_shared_palette: Option<Vec<Rgb>>,

     /// Cell height in pixels.
-    pub cell_height: usize,
+    pub cell_height: f32,

     /// Cell width in pixels.
-    pub cell_width: usize,
+    pub cell_width: f32,
 }

 impl Graphics {
@@ -141,19 +194,35 @@ impl Graphics {
     ///
     /// If all queues are empty, it returns `None`.
     pub fn take_queues(&mut self) -> Option<UpdateQueues> {
-        let mut remove_queue = self.remove_queue.lock();
-        if remove_queue.is_empty() && self.pending.is_empty() {
+        let texture_operations = {
+            let mut queue = self.texture_operations.lock();
+            if queue.is_empty() {
+                Vec::new()
+            } else {
+                mem::take(&mut *queue)
+            }
+        };
+
+        if texture_operations.is_empty() && self.pending.is_empty() {
             return None;
         }

-        let remove_queue = mem::take(&mut *remove_queue);
+        let mut remove_queue = Vec::new();
+        let mut clear_subregions = Vec::new();
+
+        for operation in texture_operations {
+            match operation {
+                TextureOperation::Remove(id) => remove_queue.push(id),
+                TextureOperation::ClearSubregion(cs) => clear_subregions.push(cs),
+            }
+        }

-        Some(UpdateQueues { pending: mem::take(&mut self.pending), remove_queue })
+        Some(UpdateQueues { pending: mem::take(&mut self.pending), remove_queue, clear_subregions })
     }

     /// Update cell dimensions.
     pub fn resize<S: Dimensions>(&mut self, size: S) {
-        self.cell_height = size.cell_height().unwrap_or(1);
-        self.cell_width = size.cell_width().unwrap_or(1);
+        self.cell_height = size.cell_height();
+        self.cell_width = size.cell_width();
     }
 }
diff --git a/alacritty_terminal/src/grid/mod.rs b/alacritty_terminal/src/grid/mod.rs
index b7ee52ec71..fd4ce6ea29 100644
--- a/alacritty_terminal/src/grid/mod.rs
+++ b/alacritty_terminal/src/grid/mod.rs
@@ -509,14 +509,14 @@ pub trait Dimensions {

     /// Cell height in pixels.
     #[inline]
-    fn cell_height(&self) -> Option<usize> {
-        None
+    fn cell_height(&self) -> f32 {
+        0.0
     }

     /// Cell width in pixels.
     #[inline]
-    fn cell_width(&self) -> Option<usize> {
-        None
+    fn cell_width(&self) -> f32 {
+        0.0
     }
 }

diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index 96ed56781d..65ced9eeb5 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -2032,8 +2032,8 @@ impl<T: EventListener> Handler for Term<T> {
     }

     fn insert_graphic(&mut self, graphic: GraphicData, palette: Option<Vec<Rgb>>) {
-        let cell_width = self.graphics.cell_width;
-        let cell_height = self.graphics.cell_height;
+        let cell_width = self.graphics.cell_width as usize;
+        let cell_height = self.graphics.cell_height as usize;

         // Store last palette if we receive a new one, and it is shared.
         if let Some(palette) = palette {
@@ -2078,7 +2078,7 @@ impl<T: EventListener> Handler for Term<T> {

         let texture = Arc::new(TextureRef {
             id: graphic_id,
-            remove_queue: Arc::downgrade(&self.graphics.remove_queue),
+            texture_operations: Arc::downgrade(&self.graphics.texture_operations),
         });

         for (top, offset_y) in (0..).zip((0..height).step_by(cell_height)) {
@@ -2094,8 +2094,19 @@ impl<T: EventListener> Handler for Term<T> {
             };

             // Store a reference to the graphic in the first column.
+            let row_len = self.grid[line].len();
             for (left, offset_x) in (leftmost..).zip((0..width).step_by(cell_width)) {
-                let graphic_cell = GraphicCell { texture: texture.clone(), offset_x, offset_y };
+                if left >= row_len {
+                    break;
+                }
+
+                let texture_operations = Arc::downgrade(&self.graphics.texture_operations);
+                let graphic_cell = GraphicCell {
+                    texture: texture.clone(),
+                    offset_x,
+                    offset_y,
+                    texture_operations,
+                };
                 let mut cell = self.grid.cursor.template.clone();
                 cell.set_graphic(graphic_cell);
                 self.grid[line][Column(left)] = cell;

From f796ba2afa445254da02157765344164d04f7dad Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Tue, 12 Jul 2022 22:39:50 +0100
Subject: [PATCH 15/29] Highlight graphics to show hints.

Similar to the underline line rendered when the cursor is over an hyperlink, for
graphics we now render a border around the graphic.
---
 alacritty/src/display/mod.rs            |  9 ++--
 alacritty/src/renderer/graphics/draw.rs | 60 +++++++++++++++++++++++--
 alacritty/src/renderer/graphics/mod.rs  | 12 ++++-
 alacritty/src/renderer/mod.rs           | 10 ++++-
 4 files changed, 80 insertions(+), 11 deletions(-)

diff --git a/alacritty/src/display/mod.rs b/alacritty/src/display/mod.rs
index c87cc124ea..195164bf53 100644
--- a/alacritty/src/display/mod.rs
+++ b/alacritty/src/display/mod.rs
@@ -819,6 +819,8 @@ impl Display {
                     // Underline hints hovered by mouse or vi mode cursor.
                     let point = term::viewport_to_point(display_offset, cell.point);

+                    let mut show_hint = false;
+
                     if has_highlighted_hint {
                         let hyperlink =
                             cell.extra.as_ref().and_then(|extra| extra.hyperlink.as_ref());
@@ -829,6 +831,7 @@ impl Display {
                                 .as_ref()
                                 .map_or(false, |hint| hint.should_highlight(point, hyperlink))
                         {
+                            show_hint = true;
                             cell.flags.insert(Flags::UNDERLINE);
                         }
                     }
@@ -837,17 +840,17 @@ impl Display {
                     lines.update(&cell);

                     // Track any graphic present in the cell.
-                    graphics_list.update(&cell);
+                    graphics_list.update(&cell, show_hint);

                     cell
                 }),
             );
         }

-        self.renderer.graphics_draw(graphics_list, &size_info);
-
         let mut rects = lines.rects(&metrics, &size_info);

+        self.renderer.graphics_draw(graphics_list, &size_info, &mut rects, &metrics);
+
         if let Some(vi_cursor_point) = vi_cursor_point {
             // Indicate vi mode by showing the cursor's position in the top right corner.
             let line = (-vi_cursor_point.line.0 + size_info.bottommost_line().0) as usize;
diff --git a/alacritty/src/renderer/graphics/draw.rs b/alacritty/src/renderer/graphics/draw.rs
index 3d0a87e148..f920782322 100644
--- a/alacritty/src/renderer/graphics/draw.rs
+++ b/alacritty/src/renderer/graphics/draw.rs
@@ -13,10 +13,13 @@ use crate::display::SizeInfo;
 use crate::gl::types::*;
 use crate::gl::{self};
 use crate::renderer::graphics::{shader, GraphicsRenderer};
+use crate::renderer::{RenderRect, Rgb};

 use alacritty_terminal::graphics::GraphicId;
 use alacritty_terminal::index::Column;

+use crossfont::Metrics;
+
 use log::trace;

 /// Position to render each texture in the grid.
@@ -25,6 +28,8 @@ struct RenderPosition {
     line: usize,
     offset_x: u16,
     offset_y: u16,
+    cell_color: Rgb,
+    show_hint: bool,
 }

 /// Track textures to be rendered in the display.
@@ -38,7 +43,7 @@ impl RenderList {
     ///
     /// The graphic is added only the first time it is found in a cell.
     #[inline]
-    pub fn update(&mut self, cell: &RenderableCell) {
+    pub fn update(&mut self, cell: &RenderableCell, show_hint: bool) {
         let graphic = match cell.extra.as_ref().and_then(|cell| cell.graphic.as_ref()) {
             Some(graphic) => graphic,
             _ => return,
@@ -53,6 +58,8 @@ impl RenderList {
             line: cell.point.line,
             offset_x: graphic.offset_x,
             offset_y: graphic.offset_y,
+            cell_color: cell.fg,
+            show_hint,
         };

         self.items.insert(graphic.id, render_item);
@@ -65,7 +72,13 @@ impl RenderList {
     }

     /// Builds a list of vertex for the shader program.
-    pub fn build_vertices(self, renderer: &GraphicsRenderer) -> Vec<shader::Vertex> {
+    fn build_vertices(
+        self,
+        renderer: &GraphicsRenderer,
+        size_info: &SizeInfo,
+        rects: &mut Vec<RenderRect>,
+        line_thickness: f32,
+    ) -> Vec<shader::Vertex> {
         use shader::VertexSide::{BottomLeft, BottomRight, TopLeft, TopRight};

         let mut vertices = Vec::new();
@@ -95,6 +108,38 @@ impl RenderList {
             for &sides in &[TopRight, BottomLeft, TopRight, BottomRight, BottomLeft] {
                 vertices.push(shader::Vertex { sides, ..vertex });
             }
+
+            if render_item.show_hint {
+                let scale = size_info.cell_height() / graphic_texture.cell_height;
+
+                let x = render_item.column.0 as f32 * size_info.cell_width()
+                    - render_item.offset_x as f32 * scale;
+                let y = render_item.line as f32 * size_info.cell_height()
+                    - render_item.offset_y as f32 * scale;
+
+                let tex_width = graphic_texture.width as f32 * scale;
+                let tex_height = graphic_texture.height as f32 * scale;
+
+                let right = x + tex_width - line_thickness;
+                let bottom = y + tex_height - line_thickness;
+
+                let template = RenderRect {
+                    x,
+                    y,
+                    width: tex_width,
+                    height: line_thickness,
+                    color: render_item.cell_color,
+                    alpha: 1.,
+                    kind: crate::renderer::rects::RectKind::Normal,
+                };
+
+                rects.push(template);
+                rects.push(RenderRect { y: bottom, ..template });
+
+                let template = RenderRect { width: line_thickness, height: tex_height, ..template };
+                rects.push(template);
+                rects.push(RenderRect { x: right, ..template });
+            }
         }

         vertices
@@ -102,8 +147,15 @@ impl RenderList {

     /// Draw graphics in the display, using the graphics rendering shader
     /// program.
-    pub fn draw(self, renderer: &GraphicsRenderer, size_info: &SizeInfo) {
-        let vertices = self.build_vertices(renderer);
+    pub fn draw(
+        self,
+        renderer: &GraphicsRenderer,
+        size_info: &SizeInfo,
+        rects: &mut Vec<RenderRect>,
+        metrics: &Metrics,
+    ) {
+        let vertices =
+            self.build_vertices(renderer, size_info, rects, metrics.underline_thickness.max(3.0));

         // Initialize the rendering program.
         unsafe {
diff --git a/alacritty/src/renderer/graphics/mod.rs b/alacritty/src/renderer/graphics/mod.rs
index 797a37112c..cb6a1c9e03 100644
--- a/alacritty/src/renderer/graphics/mod.rs
+++ b/alacritty/src/renderer/graphics/mod.rs
@@ -3,10 +3,12 @@
 use std::mem;

 use crate::display::SizeInfo;
+use crate::renderer::RenderRect;
 use alacritty_terminal::graphics::{
     ClearSubregion, ColorType, GraphicData, GraphicId, UpdateQueues,
 };

+use crossfont::Metrics;
 use log::trace;
 use serde::{Deserialize, Serialize};

@@ -248,9 +250,15 @@ impl GraphicsRenderer {

     /// Draw graphics in the display.
     #[inline]
-    pub fn draw(&mut self, render_list: RenderList, size_info: &SizeInfo) {
+    pub fn draw(
+        &mut self,
+        render_list: RenderList,
+        size_info: &SizeInfo,
+        rects: &mut Vec<RenderRect>,
+        metrics: &Metrics,
+    ) {
         if !render_list.is_empty() {
-            render_list.draw(self, size_info);
+            render_list.draw(self, size_info, rects, metrics);
         }
     }
 }
diff --git a/alacritty/src/renderer/mod.rs b/alacritty/src/renderer/mod.rs
index 8d1058ff4f..898df15d38 100644
--- a/alacritty/src/renderer/mod.rs
+++ b/alacritty/src/renderer/mod.rs
@@ -239,9 +239,15 @@ impl Renderer {

     /// Draw graphics visible in the display.
     #[inline]
-    pub fn graphics_draw(&mut self, render_list: graphics::RenderList, size_info: &SizeInfo) {
+    pub fn graphics_draw(
+        &mut self,
+        render_list: graphics::RenderList,
+        size_info: &SizeInfo,
+        rects: &mut Vec<RenderRect>,
+        metrics: &Metrics,
+    ) {
         if let Some(graphics_renderer) = self.graphics_renderer.as_mut() {
-            graphics_renderer.draw(render_list, size_info);
+            graphics_renderer.draw(render_list, size_info, rects, metrics);
         }

         self.reset_active_tex();

From dae81e0af69d6f0c4249f09f3ae7646ce2782170 Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Wed, 13 Jul 2022 14:07:33 +0100
Subject: [PATCH 16/29] Allow overlapping graphics.

If a graphic is added over another one, the implementation now checks if new
graphic has transparent pixels in every cell. If so, the graphic is appended to
the cell, instead of replacing the previous one.

SmallVec is used to prevent heap allocation when the cell only contains a single
graphic. This should be the most common scenario.

The GPU will store up to 100 textures. If another texture is added when there
are 100, the oldest one is deleted.
---
 Cargo.lock                               |  6 +-
 alacritty/Cargo.toml                     |  1 +
 alacritty/src/display/content.rs         | 19 ++++--
 alacritty/src/renderer/graphics/draw.rs  | 30 +++++-----
 alacritty/src/renderer/graphics/mod.rs   | 21 +++++--
 alacritty_terminal/Cargo.toml            |  1 +
 alacritty_terminal/src/graphics/mod.rs   | 74 ++++++++++++++++++++++++
 alacritty_terminal/src/graphics/sixel.rs |  8 +++
 alacritty_terminal/src/term/cell.rs      | 24 ++++++--
 alacritty_terminal/src/term/mod.rs       | 33 +++++++++--
 10 files changed, 178 insertions(+), 39 deletions(-)

diff --git a/Cargo.lock b/Cargo.lock
index 45407391dc..22d61dfc31 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -37,6 +37,7 @@ dependencies = [
  "serde",
  "serde_json",
  "serde_yaml",
+ "smallvec",
  "unicode-width",
  "wayland-client",
  "winapi 0.3.9",
@@ -78,6 +79,7 @@ dependencies = [
  "serde_yaml",
  "signal-hook",
  "signal-hook-mio",
+ "smallvec",
  "unicode-width",
  "vte",
  "winapi 0.3.9",
@@ -1528,9 +1530,9 @@ checksum = "eb703cfe953bccee95685111adeedb76fabe4e97549a58d16f03ea7b9367bb32"

 [[package]]
 name = "smallvec"
-version = "1.8.0"
+version = "1.9.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "f2dd574626839106c320a323308629dcb1acfc96e32a8cba364ddc61ac23ee83"
+checksum = "2fd0db749597d91ff862fd1d55ea87f7855a744a8425a64695b6fca237d1dad1"

 [[package]]
 name = "smithay-client-toolkit"
diff --git a/alacritty/Cargo.toml b/alacritty/Cargo.toml
index e93723bc52..73510e2d9d 100644
--- a/alacritty/Cargo.toml
+++ b/alacritty/Cargo.toml
@@ -36,6 +36,7 @@ bitflags = "1"
 memoffset = "0.6.4"
 dirs = "4.0.0"
 once_cell = "1.12"
+smallvec = { version = "1.9.0", default-features = false }

 [build-dependencies]
 gl_generator = "0.14.0"
diff --git a/alacritty/src/display/content.rs b/alacritty/src/display/content.rs
index 9e179009d8..82644018b7 100644
--- a/alacritty/src/display/content.rs
+++ b/alacritty/src/display/content.rs
@@ -19,6 +19,8 @@ use crate::display::hint::{self, HintState};
 use crate::display::Display;
 use crate::event::SearchState;

+use smallvec::SmallVec;
+
 /// Minimum contrast between a fixed cursor color and the cell's background.
 pub const MIN_CURSOR_CONTRAST: f64 = 1.5;

@@ -209,7 +211,7 @@ pub struct RenderableGraphicCell {
 pub struct RenderableCellExtra {
     pub zerowidth: Option<Vec<char>>,
     pub hyperlink: Option<Hyperlink>,
-    pub graphic: Option<RenderableGraphicCell>,
+    pub graphics: Option<SmallVec<[RenderableGraphicCell; 1]>>,
 }

 impl RenderableCell {
@@ -282,17 +284,22 @@ impl RenderableCell {
         let zerowidth = cell.zerowidth();
         let hyperlink = cell.hyperlink();

-        let graphic = cell.graphic().map(|graphic| RenderableGraphicCell {
-            id: graphic.texture.id,
-            offset_x: graphic.offset_x,
-            offset_y: graphic.offset_y,
+        let graphics = cell.graphics().map(|graphics| {
+            graphics
+                .iter()
+                .map(|graphic| RenderableGraphicCell {
+                    id: graphic.texture.id,
+                    offset_x: graphic.offset_x,
+                    offset_y: graphic.offset_y,
+                })
+                .collect::<_>()
         });

         let extra = (zerowidth.is_some() || hyperlink.is_some()).then(|| {
             Box::new(RenderableCellExtra {
                 zerowidth: zerowidth.map(|zerowidth| zerowidth.to_vec()),
                 hyperlink,
-                graphic,
+                graphics,
             })
         });

diff --git a/alacritty/src/renderer/graphics/draw.rs b/alacritty/src/renderer/graphics/draw.rs
index f920782322..5f04a267bd 100644
--- a/alacritty/src/renderer/graphics/draw.rs
+++ b/alacritty/src/renderer/graphics/draw.rs
@@ -44,25 +44,27 @@ impl RenderList {
     /// The graphic is added only the first time it is found in a cell.
     #[inline]
     pub fn update(&mut self, cell: &RenderableCell, show_hint: bool) {
-        let graphic = match cell.extra.as_ref().and_then(|cell| cell.graphic.as_ref()) {
-            Some(graphic) => graphic,
+        let graphics = match cell.extra.as_ref().and_then(|cell| cell.graphics.as_ref()) {
+            Some(graphics) => graphics,
             _ => return,
         };

-        if self.items.contains_key(&graphic.id) {
-            return;
-        }
+        for graphic in graphics {
+            if self.items.contains_key(&graphic.id) {
+                continue;
+            }

-        let render_item = RenderPosition {
-            column: cell.point.column,
-            line: cell.point.line,
-            offset_x: graphic.offset_x,
-            offset_y: graphic.offset_y,
-            cell_color: cell.fg,
-            show_hint,
-        };
+            let render_item = RenderPosition {
+                column: cell.point.column,
+                line: cell.point.line,
+                offset_x: graphic.offset_x,
+                offset_y: graphic.offset_y,
+                cell_color: cell.fg,
+                show_hint,
+            };

-        self.items.insert(graphic.id, render_item);
+            self.items.insert(graphic.id, render_item);
+        }
     }

     /// Returns `true` if there are no items to render.
diff --git a/alacritty/src/renderer/graphics/mod.rs b/alacritty/src/renderer/graphics/mod.rs
index cb6a1c9e03..5a6c59a7aa 100644
--- a/alacritty/src/renderer/graphics/mod.rs
+++ b/alacritty/src/renderer/graphics/mod.rs
@@ -22,6 +22,9 @@ use std::ffi::CStr;
 mod draw;
 mod shader;

+/// Max. number of textures stored in the GPU.
+const MAX_TEXTURES_COUNT: usize = 100;
+
 pub use draw::RenderList;

 bitflags::bitflags! {
@@ -125,11 +128,9 @@ impl GraphicsRenderer {
         graphics: Vec<GraphicData>,
         size_info: &SizeInfo,
     ) -> UpdateResult {
-        let result = if graphics.is_empty() {
-            UpdateResult::SUCCESS
-        } else {
-            UpdateResult::NEED_RESET_ACTIVE_TEX
-        };
+        if graphics.is_empty() {
+            return UpdateResult::SUCCESS;
+        }

         for graphic in graphics {
             let mut texture = 0;
@@ -176,7 +177,15 @@ impl GraphicsRenderer {
             self.graphic_textures.insert(graphic.id, graphic_texture);
         }

-        result
+        // If we exceed the textures limit, discard the oldest ones.
+        while self.graphic_textures.len() > MAX_TEXTURES_COUNT {
+            match self.graphic_textures.keys().min().copied() {
+                Some(id) => self.graphic_textures.remove(&id),
+                None => unreachable!(),
+            };
+        }
+
+        UpdateResult::NEED_RESET_ACTIVE_TEX
     }

     /// Update textures in the GPU to clear specific subregions.
diff --git a/alacritty_terminal/Cargo.toml b/alacritty_terminal/Cargo.toml
index e758009cb4..f1c1e50f7b 100644
--- a/alacritty_terminal/Cargo.toml
+++ b/alacritty_terminal/Cargo.toml
@@ -27,6 +27,7 @@ unicode-width = "0.1"
 base64 = "0.13.0"
 regex-automata = "0.1.9"
 dirs = "4.0.0"
+smallvec = { version = "1.9.0", default-features = false }

 [target.'cfg(unix)'.dependencies]
 nix = "0.22.0"
diff --git a/alacritty_terminal/src/graphics/mod.rs b/alacritty_terminal/src/graphics/mod.rs
index 846d866c95..175dce771b 100644
--- a/alacritty_terminal/src/graphics/mod.rs
+++ b/alacritty_terminal/src/graphics/mod.rs
@@ -8,6 +8,7 @@ use std::sync::{Arc, Weak};

 use parking_lot::Mutex;
 use serde::{Deserialize, Serialize};
+use smallvec::SmallVec;

 use crate::grid::Dimensions;
 use crate::term::color::Rgb;
@@ -49,6 +50,9 @@ impl Drop for TextureRef {
     }
 }

+/// A list of graphics in a single cell.
+pub type GraphicsCell = SmallVec<[GraphicCell; 1]>;
+
 /// Graphic data stored in a single cell.
 #[derive(Clone, Debug)]
 pub struct GraphicCell {
@@ -123,6 +127,39 @@ pub struct GraphicData {

     /// Pixels data.
     pub pixels: Vec<u8>,
+
+    /// Indicate if there are no transparent pixels.
+    pub is_opaque: bool,
+}
+
+impl GraphicData {
+    /// Check if all pixels under a region are opaque.
+    pub fn is_filled(&self, x: usize, y: usize, width: usize, height: usize) -> bool {
+        // If there are pixels outside the picture we assume that the region is
+        // not filled.
+        if x + width >= self.width || y + height > self.height {
+            return false;
+        }
+
+        // Don't check actual pixels if the image does not contain an alpha
+        // channel.
+        if self.is_opaque || self.color_type == ColorType::Rgb {
+            return true;
+        }
+
+        debug_assert!(self.color_type == ColorType::Rgba);
+
+        for offset_y in y..y + height {
+            let offset = offset_y * self.width * 4;
+            let row = &self.pixels[offset..offset + width * 4];
+
+            if row.chunks_exact(4).any(|pixel| pixel.last() != Some(&255)) {
+                return false;
+            }
+        }
+
+        true
+    }
 }

 /// Operation to clear a subregion in an existing graphic.
@@ -226,3 +263,40 @@ impl Graphics {
         self.cell_width = size.cell_width();
     }
 }
+
+#[test]
+fn check_opaque_region() {
+    let graphic = GraphicData {
+        id: GraphicId(0),
+        width: 10,
+        height: 10,
+        color_type: ColorType::Rgb,
+        pixels: vec![255; 10 * 10 * 3],
+        is_opaque: true,
+    };
+
+    assert_eq!(graphic.is_filled(1, 1, 3, 3), true);
+    assert_eq!(graphic.is_filled(8, 8, 10, 10), false);
+
+    let pixels = {
+        // Put a transparent 3x3 box inside the picture.
+        let mut data = vec![255; 10 * 10 * 4];
+        for y in 3..6 {
+            let offset = y * 10 * 4;
+            data[offset..offset + 3 * 4].fill(0);
+        }
+        data
+    };
+
+    let graphic = GraphicData {
+        id: GraphicId(0),
+        pixels,
+        width: 10,
+        height: 10,
+        color_type: ColorType::Rgba,
+        is_opaque: false,
+    };
+
+    assert_eq!(graphic.is_filled(0, 0, 3, 3), true);
+    assert_eq!(graphic.is_filled(1, 1, 4, 4), false);
+}
diff --git a/alacritty_terminal/src/graphics/sixel.rs b/alacritty_terminal/src/graphics/sixel.rs
index c243501bbf..a3a13886f0 100644
--- a/alacritty_terminal/src/graphics/sixel.rs
+++ b/alacritty_terminal/src/graphics/sixel.rs
@@ -485,9 +485,12 @@ impl Parser {

         let mut rgba_pixels = Vec::with_capacity(self.pixels.len() * 4);

+        let mut is_opaque = true;
+
         for &register in &self.pixels {
             let pixel = {
                 if register == REG_TRANSPARENT {
+                    is_opaque = false;
                     [0; 4]
                 } else {
                     match self.color_registers.get(register.0 as usize) {
@@ -506,6 +509,7 @@ impl Parser {
             width: self.width,
             color_type: ColorType::Rgba,
             pixels: rgba_pixels,
+            is_opaque,
         };

         Ok((data, self.color_registers))
@@ -699,6 +703,9 @@ mod tests {
             }
         }

+        let graphics = parser.finish()?.0;
+        assert_eq!(graphics.is_opaque, false);
+
         Ok(())
     }

@@ -770,6 +777,7 @@ mod tests {
             };

             assert_eq!(graphics.pixels, expected_rgba);
+            assert_eq!(graphics.is_opaque, true);
         }
     }
 }
diff --git a/alacritty_terminal/src/term/cell.rs b/alacritty_terminal/src/term/cell.rs
index 99b7eef4f3..7756bfa01e 100644
--- a/alacritty_terminal/src/term/cell.rs
+++ b/alacritty_terminal/src/term/cell.rs
@@ -5,7 +5,7 @@ use bitflags::bitflags;
 use serde::{Deserialize, Serialize};

 use crate::ansi::{Color, NamedColor};
-use crate::graphics::GraphicCell;
+use crate::graphics::GraphicsCell;
 use crate::grid::{self, GridCell};
 use crate::index::Column;

@@ -115,7 +115,7 @@ pub struct CellExtra {
     hyperlink: Option<Hyperlink>,

     #[serde(skip)]
-    graphic: Option<Box<GraphicCell>>,
+    graphics: Option<GraphicsCell>,
 }

 /// Content and attributes of a single cell in the terminal grid.
@@ -157,15 +157,27 @@ impl Cell {

     /// Graphic present in the cell.
     #[inline]
-    pub fn graphic(&self) -> Option<&GraphicCell> {
-        self.extra.as_deref().and_then(|extra| extra.graphic.as_deref())
+    pub fn graphics(&self) -> Option<&GraphicsCell> {
+        self.extra.as_deref().and_then(|extra| extra.graphics.as_ref())
+    }
+
+    /// Extract the graphics value from the cell.
+    #[inline]
+    pub fn take_graphics(&mut self) -> Option<GraphicsCell> {
+        if let Some(extra) = &mut self.extra {
+            if extra.graphics.is_some() {
+                return Arc::make_mut(extra).graphics.take();
+            }
+        }
+
+        None
     }

     /// Write the graphic data in the cell.
     #[inline]
-    pub fn set_graphic(&mut self, graphic_cell: GraphicCell) {
+    pub fn set_graphics(&mut self, graphics_cell: GraphicsCell) {
         let extra = self.extra.get_or_insert_with(Default::default);
-        Arc::make_mut(extra).graphic = Some(Box::new(graphic_cell));
+        Arc::make_mut(extra).graphics = Some(graphics_cell);

         self.flags_mut().insert(Flags::GRAPHICS);
     }
diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index 65ced9eeb5..5de2695daa 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -2053,9 +2053,7 @@ impl<T: EventListener> Handler for Term<T> {
             return;
         }

-        // Add the graphic data to the pending queue.
         let graphic_id = self.graphics.next_id();
-        self.graphics.pending.push(GraphicData { id: graphic_id, ..graphic });

         // If SIXEL_DISPLAY is disabled, the start of the graphic is the
         // cursor position, and the grid can be scrolled if the graphic is
@@ -2107,12 +2105,34 @@ impl<T: EventListener> Handler for Term<T> {
                     offset_y,
                     texture_operations,
                 };
+
                 let mut cell = self.grid.cursor.template.clone();
-                cell.set_graphic(graphic_cell);
-                self.grid[line][Column(left)] = cell;
+                let cell_ref = &mut self.grid[line][Column(left)];
+
+                // If the cell contains any graphics, and the region of the cell
+                // is not fully filled by the new graphic, the old graphics are
+                // kept in the cell
+                let graphics = loop {
+                    if let Some(mut old_graphics) = cell_ref.take_graphics() {
+                        if !graphic.is_filled(
+                            offset_x as usize,
+                            offset_y as usize,
+                            cell_width as usize,
+                            cell_height as usize,
+                        ) {
+                            old_graphics.push(graphic_cell);
+                            break old_graphics;
+                        }
+                    }
+
+                    break smallvec::smallvec![graphic_cell];
+                };
+
+                cell.set_graphics(graphics);
+                *cell_ref = cell;
             }

-            if scrolling && offset_y < height - cell_height as u16 {
+            if scrolling && offset_y < height.saturating_sub(cell_height as u16) {
                 self.linefeed();
             }
         }
@@ -2124,6 +2144,9 @@ impl<T: EventListener> Handler for Term<T> {
             self.linefeed();
             self.carriage_return();
         }
+
+        // Add the graphic data to the pending queue.
+        self.graphics.pending.push(GraphicData { id: graphic_id, ..graphic });
     }
 }


From 111986f9c056e813dceb6b1dc3a84c6769edfad5 Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Wed, 13 Jul 2022 21:31:21 +0100
Subject: [PATCH 17/29] Optimize graphics replacement.

A simple optimization for inserting graphics is to detect when a new graphic is
replacing completely an existing one. If both graphics have the same size, and
the new one is opaque, we can assume that the previous graphic will not be
displayed anymore, so it is not considered when update the graphics list in a
single cell.

This commit also adds serde implementation for GraphicsCell. This was used to
debug the new logic.
---
 Cargo.lock                             |  3 +
 alacritty/Cargo.toml                   |  2 +-
 alacritty_terminal/Cargo.toml          |  2 +-
 alacritty_terminal/src/graphics/mod.rs | 81 +++++++++++++++++++++++++-
 alacritty_terminal/src/term/cell.rs    |  2 +-
 alacritty_terminal/src/term/mod.rs     | 76 ++++++++++++++++++------
 6 files changed, 143 insertions(+), 23 deletions(-)

diff --git a/Cargo.lock b/Cargo.lock
index 22d61dfc31..0a8bb06bc5 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -1533,6 +1533,9 @@ name = "smallvec"
 version = "1.9.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "2fd0db749597d91ff862fd1d55ea87f7855a744a8425a64695b6fca237d1dad1"
+dependencies = [
+ "serde",
+]

 [[package]]
 name = "smithay-client-toolkit"
diff --git a/alacritty/Cargo.toml b/alacritty/Cargo.toml
index 73510e2d9d..5c0914e6ad 100644
--- a/alacritty/Cargo.toml
+++ b/alacritty/Cargo.toml
@@ -36,7 +36,7 @@ bitflags = "1"
 memoffset = "0.6.4"
 dirs = "4.0.0"
 once_cell = "1.12"
-smallvec = { version = "1.9.0", default-features = false }
+smallvec = { version = "1.9.0", features = ["serde"] }

 [build-dependencies]
 gl_generator = "0.14.0"
diff --git a/alacritty_terminal/Cargo.toml b/alacritty_terminal/Cargo.toml
index f1c1e50f7b..c798e065fc 100644
--- a/alacritty_terminal/Cargo.toml
+++ b/alacritty_terminal/Cargo.toml
@@ -27,7 +27,7 @@ unicode-width = "0.1"
 base64 = "0.13.0"
 regex-automata = "0.1.9"
 dirs = "4.0.0"
-smallvec = { version = "1.9.0", default-features = false }
+smallvec = { version = "1.9.0", features = ["serde"] }

 [target.'cfg(unix)'.dependencies]
 nix = "0.22.0"
diff --git a/alacritty_terminal/src/graphics/mod.rs b/alacritty_terminal/src/graphics/mod.rs
index 175dce771b..30c55ba08a 100644
--- a/alacritty_terminal/src/graphics/mod.rs
+++ b/alacritty_terminal/src/graphics/mod.rs
@@ -7,7 +7,7 @@ use std::mem;
 use std::sync::{Arc, Weak};

 use parking_lot::Mutex;
-use serde::{Deserialize, Serialize};
+use serde::{Deserialize, Deserializer, Serialize, Serializer};
 use smallvec::SmallVec;

 use crate::grid::Dimensions;
@@ -29,6 +29,15 @@ pub struct TextureRef {
     /// Graphic identifier.
     pub id: GraphicId,

+    /// Width, in pixels, of the graphic.
+    pub width: u16,
+
+    /// Height, in pixels, of the graphic.
+    pub height: u16,
+
+    /// Height, in pixels, of the cell when the graphic was inserted.
+    pub cell_height: usize,
+
     /// Queue to track removed references.
     pub texture_operations: Weak<Mutex<Vec<TextureOperation>>>,
 }
@@ -92,6 +101,62 @@ impl Drop for GraphicCell {
     }
 }

+#[derive(Deserialize, Serialize)]
+struct GraphicCellSerde {
+    texture: GraphicId,
+    offset_x: u16,
+    offset_y: u16,
+    tex_width: u16,
+    tex_height: u16,
+    tex_cell_height: usize,
+}
+
+impl<'de> Deserialize<'de> for GraphicCell {
+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
+    where
+        D: Deserializer<'de>,
+    {
+        let data = GraphicCellSerde::deserialize(deserializer)?;
+
+        let dummy_queue = Arc::new(Mutex::new(Vec::new()));
+
+        let texture = TextureRef {
+            id: data.texture,
+            width: data.tex_width,
+            height: data.tex_height,
+            cell_height: data.tex_cell_height,
+            texture_operations: Arc::downgrade(&dummy_queue),
+        };
+
+        let graphic_cell = GraphicCell {
+            texture: Arc::new(texture),
+            offset_x: data.offset_x,
+            offset_y: data.offset_y,
+            texture_operations: Arc::downgrade(&dummy_queue),
+        };
+
+        Ok(graphic_cell)
+    }
+}
+
+impl Serialize for GraphicCell {
+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
+    where
+        S: Serializer,
+    {
+        let data = GraphicCellSerde {
+            texture: self.texture.id,
+            offset_x: self.offset_x,
+            offset_y: self.offset_y,
+            tex_width: self.texture.width,
+            tex_height: self.texture.height,
+            tex_cell_height: self.texture.cell_height,
+        };
+
+        data.serialize(serializer)
+    }
+}
+
 impl GraphicCell {
     /// Graphic identifier of the texture in this cell.
     #[inline]
@@ -133,17 +198,27 @@ pub struct GraphicData {
 }

 impl GraphicData {
+    /// Check if the image may contain transparent pixels. If it returns
+    /// `false`, it is guaranteed that there are no transparent pixels.
+    #[inline]
+    pub fn maybe_transparent(&self) -> bool {
+        !self.is_opaque && self.color_type == ColorType::Rgba
+    }
+
     /// Check if all pixels under a region are opaque.
+    ///
+    /// If the region exceeds the boundaries of the image it is considered as
+    /// not filled.
     pub fn is_filled(&self, x: usize, y: usize, width: usize, height: usize) -> bool {
         // If there are pixels outside the picture we assume that the region is
         // not filled.
-        if x + width >= self.width || y + height > self.height {
+        if x + width >= self.width || y + height >= self.height {
             return false;
         }

         // Don't check actual pixels if the image does not contain an alpha
         // channel.
-        if self.is_opaque || self.color_type == ColorType::Rgb {
+        if !self.maybe_transparent() {
             return true;
         }

diff --git a/alacritty_terminal/src/term/cell.rs b/alacritty_terminal/src/term/cell.rs
index 7756bfa01e..f04bb95bb4 100644
--- a/alacritty_terminal/src/term/cell.rs
+++ b/alacritty_terminal/src/term/cell.rs
@@ -114,7 +114,7 @@ pub struct CellExtra {

     hyperlink: Option<Hyperlink>,

-    #[serde(skip)]
+    #[serde(skip_serializing_if = "Option::is_none")]
     graphics: Option<GraphicsCell>,
 }

diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index 5de2695daa..3d71a95544 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -1,5 +1,6 @@
 //! Exports the `Term` type which is a high-level API for the Grid.

+use std::collections::HashSet;
 use std::fmt::Write;
 use std::ops::{Index, IndexMut, Range};
 use std::sync::Arc;
@@ -2065,6 +2066,43 @@ impl<T: EventListener> Handler for Term<T> {

         let scrolling = !self.mode.contains(TermMode::SIXEL_DISPLAY);

+        let leftmost = if scrolling { self.grid.cursor.point.column.0 } else { 0 };
+
+        // A very simple optimization is to detect is a new graphic is replacing
+        // completely a previous one. This happens if the following conditions
+        // are met:
+        //
+        // - Both graphics are attached to the same top-left cell.
+        // - Both graphics have the same size.
+        // - The new graphic does not contain transparent pixels.
+        //
+        // In this case, we will ignore cells with a reference to the replaced
+        // graphic.
+
+        let skip_textures = {
+            if graphic.maybe_transparent() {
+                HashSet::new()
+            } else {
+                let mut set = HashSet::new();
+
+                let line = if scrolling { self.grid.cursor.point.line } else { Line(0) };
+
+                if let Some(old_graphics) = self.grid[line][Column(leftmost)].graphics() {
+                    for graphic in old_graphics {
+                        let tex = &*graphic.texture;
+                        if tex.width == width
+                            && tex.height == height
+                            && tex.cell_height == cell_height
+                        {
+                            set.insert(tex.id);
+                        }
+                    }
+                }
+
+                set
+            }
+        };
+
         // Fill the cells under the graphic.
         //
         // The cell in the first column contains a reference to the
@@ -2072,10 +2110,11 @@ impl<T: EventListener> Handler for Term<T> {
         // cells are not overwritten, allowing any text behind
         // transparent portions of the image to be visible.

-        let leftmost = if scrolling { self.grid.cursor.point.column.0 } else { 0 };
-
         let texture = Arc::new(TextureRef {
             id: graphic_id,
+            width,
+            height,
+            cell_height,
             texture_operations: Arc::downgrade(&self.graphics.texture_operations),
         });

@@ -2111,21 +2150,24 @@ impl<T: EventListener> Handler for Term<T> {

                 // If the cell contains any graphics, and the region of the cell
                 // is not fully filled by the new graphic, the old graphics are
-                // kept in the cell
-                let graphics = loop {
-                    if let Some(mut old_graphics) = cell_ref.take_graphics() {
-                        if !graphic.is_filled(
-                            offset_x as usize,
-                            offset_y as usize,
-                            cell_width as usize,
-                            cell_height as usize,
-                        ) {
-                            old_graphics.push(graphic_cell);
-                            break old_graphics;
-                        }
-                    }
-
-                    break smallvec::smallvec![graphic_cell];
+                // kept in the cell.
+                let graphics = match cell_ref.take_graphics() {
+                    Some(mut old_graphics)
+                        if old_graphics
+                            .iter()
+                            .any(|graphic| !skip_textures.contains(&graphic.texture.id))
+                            && !graphic.is_filled(
+                                offset_x as usize,
+                                offset_y as usize,
+                                cell_width as usize,
+                                cell_height as usize,
+                            ) =>
+                    {
+                        old_graphics.push(graphic_cell);
+                        old_graphics
+                    },
+
+                    _ => smallvec::smallvec![graphic_cell],
                 };

                 cell.set_graphics(graphics);

From 1c6a770805f4ce664fe3118b82f15d23cc171020 Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Thu, 14 Jul 2022 23:21:19 +0100
Subject: [PATCH 18/29] Fix clippy warnings.

---
 alacritty_terminal/src/graphics/mod.rs   | 8 ++++----
 alacritty_terminal/src/graphics/sixel.rs | 4 ++--
 2 files changed, 6 insertions(+), 6 deletions(-)

diff --git a/alacritty_terminal/src/graphics/mod.rs b/alacritty_terminal/src/graphics/mod.rs
index 30c55ba08a..b6f58a11b0 100644
--- a/alacritty_terminal/src/graphics/mod.rs
+++ b/alacritty_terminal/src/graphics/mod.rs
@@ -350,8 +350,8 @@ fn check_opaque_region() {
         is_opaque: true,
     };

-    assert_eq!(graphic.is_filled(1, 1, 3, 3), true);
-    assert_eq!(graphic.is_filled(8, 8, 10, 10), false);
+    assert!(graphic.is_filled(1, 1, 3, 3));
+    assert!(!graphic.is_filled(8, 8, 10, 10));

     let pixels = {
         // Put a transparent 3x3 box inside the picture.
@@ -372,6 +372,6 @@ fn check_opaque_region() {
         is_opaque: false,
     };

-    assert_eq!(graphic.is_filled(0, 0, 3, 3), true);
-    assert_eq!(graphic.is_filled(1, 1, 4, 4), false);
+    assert!(graphic.is_filled(0, 0, 3, 3));
+    assert!(!graphic.is_filled(1, 1, 4, 4));
 }
diff --git a/alacritty_terminal/src/graphics/sixel.rs b/alacritty_terminal/src/graphics/sixel.rs
index a3a13886f0..42ffda745e 100644
--- a/alacritty_terminal/src/graphics/sixel.rs
+++ b/alacritty_terminal/src/graphics/sixel.rs
@@ -704,7 +704,7 @@ mod tests {
         }

         let graphics = parser.finish()?.0;
-        assert_eq!(graphics.is_opaque, false);
+        assert!(!graphics.is_opaque);

         Ok(())
     }
@@ -777,7 +777,7 @@ mod tests {
             };

             assert_eq!(graphics.pixels, expected_rgba);
-            assert_eq!(graphics.is_opaque, true);
+            assert!(graphics.is_opaque);
         }
     }
 }

From e521d6e13576ab2c445c14a8a78a00d09a5a87fa Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Fri, 15 Jul 2022 13:28:27 +0100
Subject: [PATCH 19/29] Use hls_to_rgb implementation from libsixel.

---
 alacritty_terminal/src/graphics/sixel.rs | 171 +++++++++++++----------
 1 file changed, 100 insertions(+), 71 deletions(-)

diff --git a/alacritty_terminal/src/graphics/sixel.rs b/alacritty_terminal/src/graphics/sixel.rs
index 42ffda745e..acad29c879 100644
--- a/alacritty_terminal/src/graphics/sixel.rs
+++ b/alacritty_terminal/src/graphics/sixel.rs
@@ -189,12 +189,12 @@ impl CommandParser {
                         };
                     }

-                    let (r, g, b) = match self.params[1] {
+                    let rgb = match self.params[1] {
                         // HLS.
                         1 => hls_to_rgb(p!(2, 360), p!(3), p!(4)),

                         // RGB.
-                        2 => (p!(2), p!(3), p!(4)),
+                        2 => rgb(p!(2), p!(3), p!(4), 100),

                         // Invalid coordinate system.
                         x => {
@@ -205,7 +205,7 @@ impl CommandParser {
                         },
                     };

-                    parser.set_color_register(register, r, g, b);
+                    parser.set_color_register(register, rgb);
                 }

                 parser.selected_color_register = register;
@@ -369,7 +369,7 @@ impl Parser {
     /// Set the RGB color for a register.
     ///
     /// Color components are expected to be in the range of 0..=100.
-    fn set_color_register(&mut self, register: ColorRegister, r: u16, g: u16, b: u16) {
+    fn set_color_register(&mut self, register: ColorRegister, rgb: Rgb) {
         let register = register.0 as usize;

         if register >= MAX_COLOR_REGISTERS {
@@ -380,10 +380,7 @@ impl Parser {
             self.color_registers.resize(register + 1, Rgb { r: 0, g: 0, b: 0 })
         }

-        let r = ((r * 255 + 50) / 100) as u8;
-        let g = ((g * 255 + 50) / 100) as u8;
-        let b = ((b * 255 + 50) / 100) as u8;
-        self.color_registers[register] = Rgb { r, g, b };
+        self.color_registers[register] = rgb;
     }

     /// Check if the current picture is big enough for the given dimensions. If
@@ -521,46 +518,43 @@ impl Parser {
 /// Input and output values are in the range of `0..=100`.
 ///
 /// The implementation is a direct port of the same function in the
-/// xterm's code.
-#[allow(clippy::many_single_char_names)]
-fn hls_to_rgb(h: u16, l: u16, s: u16) -> (u16, u16, u16) {
-    if s == 0 {
-        return (l, l, l);
+/// libsixel's code.
+fn hls_to_rgb(hue: u16, lum: u16, sat: u16) -> Rgb {
+    if sat == 0 {
+        return rgb(lum, lum, lum, 100);
     }

-    let hs = ((h + 240) / 60) % 6;
-    let lv = l as f64 / 100.0;
+    let lum = lum as f64;

-    let c2 = f64::abs((2.0 * lv as f64) - 1.0);
-    let c = (1.0 - c2) * (s as f64 / 100.0);
-    let x = if hs & 1 == 1 { c } else { 0.0 };
+    let c0 = if lum > 50.0 { ((lum * 4.0) / 100.0) - 1.0 } else { -(2.0 * (lum / 100.0) - 1.0) };
+    let c = sat as f64 * (1.0 - c0) / 2.0;

-    let rgb = match hs {
-        0 => (c, x, 0.),
-        1 => (x, c, 0.),
-        2 => (0., c, x),
-        3 => (0., x, c),
-        4 => (x, 0., c),
-        _ => (c, 0., c),
+    let max = lum + c;
+    let min = lum - c;
+
+    let hue = (hue + 240) % 360;
+    let h = hue as f64;
+
+    let (r, g, b) = match hue / 60 {
+        0 => (max, min + (max - min) * (h / 60.0), min),
+        1 => (min + (max - min) * ((120.0 - h) / 60.0), max, min),
+        2 => (min, max, min + (max - min) * ((h - 120.0) / 60.0)),
+        3 => (min, min + (max - min) * ((240.0 - h) / 60.0), max),
+        4 => (min + (max - min) * ((h - 240.0) / 60.0), min, max),
+        5 => (max, min, min + (max - min) * ((360.0 - h) / 60.0)),
+        _ => (0., 0., 0.),
     };

-    fn clamp(x: f64) -> u16 {
-        let x = x * 100. + 0.5;
-        if x > 100. {
-            100
-        } else if x < 0. {
+    fn clamp(x: f64) -> u8 {
+        let x = f64::round(x * 255. / 100.) % 256.;
+        if x < 0. {
             0
         } else {
-            x as u16
+            x as u8
         }
     }

-    let m = lv - 0.5 * c;
-    let r = clamp(rgb.0 + m);
-    let g = clamp(rgb.1 + m);
-    let b = clamp(rgb.2 + m);
-
-    (r, g, b)
+    Rgb { r: clamp(r), g: clamp(g), b: clamp(b) }
 }

 /// Initialize the color registers using the colors from the VT-340 terminal.
@@ -568,22 +562,35 @@ fn hls_to_rgb(h: u16, l: u16, s: u16) -> (u16, u16, u16) {
 /// There is no official documentation about these colors, but multiple Sixel
 /// implementations assume this palette.
 fn init_color_registers(parser: &mut Parser) {
-    parser.set_color_register(ColorRegister(0), 0, 0, 0);
-    parser.set_color_register(ColorRegister(1), 20, 20, 80);
-    parser.set_color_register(ColorRegister(2), 80, 13, 13);
-    parser.set_color_register(ColorRegister(3), 20, 80, 20);
-    parser.set_color_register(ColorRegister(4), 80, 20, 80);
-    parser.set_color_register(ColorRegister(5), 20, 80, 80);
-    parser.set_color_register(ColorRegister(6), 80, 80, 20);
-    parser.set_color_register(ColorRegister(7), 53, 53, 53);
-    parser.set_color_register(ColorRegister(8), 26, 26, 26);
-    parser.set_color_register(ColorRegister(9), 33, 33, 60);
-    parser.set_color_register(ColorRegister(10), 60, 26, 26);
-    parser.set_color_register(ColorRegister(11), 33, 60, 33);
-    parser.set_color_register(ColorRegister(12), 60, 33, 60);
-    parser.set_color_register(ColorRegister(13), 33, 60, 60);
-    parser.set_color_register(ColorRegister(14), 60, 60, 33);
-    parser.set_color_register(ColorRegister(15), 80, 80, 80);
+    parser.set_color_register(ColorRegister(0), rgb(0, 0, 0, 100));
+    parser.set_color_register(ColorRegister(1), rgb(20, 20, 80, 100));
+    parser.set_color_register(ColorRegister(2), rgb(80, 13, 13, 100));
+    parser.set_color_register(ColorRegister(3), rgb(20, 80, 20, 100));
+    parser.set_color_register(ColorRegister(4), rgb(80, 20, 80, 100));
+    parser.set_color_register(ColorRegister(5), rgb(20, 80, 80, 100));
+    parser.set_color_register(ColorRegister(6), rgb(80, 80, 20, 100));
+    parser.set_color_register(ColorRegister(7), rgb(53, 53, 53, 100));
+    parser.set_color_register(ColorRegister(8), rgb(26, 26, 26, 100));
+    parser.set_color_register(ColorRegister(9), rgb(33, 33, 60, 100));
+    parser.set_color_register(ColorRegister(10), rgb(60, 26, 26, 100));
+    parser.set_color_register(ColorRegister(11), rgb(33, 60, 33, 100));
+    parser.set_color_register(ColorRegister(12), rgb(60, 33, 60, 100));
+    parser.set_color_register(ColorRegister(13), rgb(33, 60, 60, 100));
+    parser.set_color_register(ColorRegister(14), rgb(60, 60, 33, 100));
+    parser.set_color_register(ColorRegister(15), rgb(80, 80, 80, 100));
+}
+
+/// Create a `Rgb` instance, scaling the components when necessary.
+#[inline]
+fn rgb(r: u16, g: u16, b: u16, max: u16) -> Rgb {
+    if max == 255 {
+        Rgb { r: r as u8, b: b as u8, g: g as u8 }
+    } else {
+        let r = ((r * 255 + max / 2) / max) as u8;
+        let g = ((g * 255 + max / 2) / max) as u8;
+        let b = ((b * 255 + max / 2) / max) as u8;
+        Rgb { r, g, b }
+    }
 }

 #[cfg(test)]
@@ -622,32 +629,54 @@ mod tests {
         assert!(parser.color_registers.len() >= 200);

         assert_eq!(parser.color_registers[1], Rgb { r: 77, g: 255, b: 0 });
-        assert_eq!(parser.color_registers[200], Rgb { r: 161, g: 161, b: 224 });
+        assert_eq!(parser.color_registers[200], Rgb { r: 213, g: 255, b: 128 });

         assert_eq!(parser.selected_color_register.0, 200);
     }

     #[test]
     fn convert_hls_colors() {
-        // This test converts values from HLS to RBG, and compares those
-        // results with the values generated by the xterm implementation
+        // This test converts some values from HLS to RBG, and compares those
+        // results with the values generated by the libsixel implementation
         // of the same function.
+        //
+        // We allow some difference between each component to ignore rounding
+        // errors.
+
+        macro_rules! assert_color {
+            ($h:expr, $l:expr, $s:expr => $r:expr, $g:expr, $b:expr) => {
+                let left = hls_to_rgb($h, $l, $s);
+                let right = rgb($r, $g, $b, 255);
+
+                assert!(
+                    left.r.abs_diff(right.r) < 4
+                        && left.g.abs_diff(right.g) < 4
+                        && left.b.abs_diff(right.b) < 4,
+                    "Expected {right:?} Found {left:?}"
+                );
+            };
+        }

-        assert_eq!(hls_to_rgb(100, 60, 60), (84, 36, 84));
-        assert_eq!(hls_to_rgb(60, 100, 60), (100, 100, 100));
-        assert_eq!(hls_to_rgb(30, 30, 60), (12, 12, 48));
-        assert_eq!(hls_to_rgb(100, 90, 100), (100, 80, 100));
-        assert_eq!(hls_to_rgb(100, 0, 90), (0, 0, 0));
-        assert_eq!(hls_to_rgb(0, 90, 30), (87, 87, 93));
-        assert_eq!(hls_to_rgb(60, 0, 60), (0, 0, 0));
-        assert_eq!(hls_to_rgb(30, 0, 0), (0, 0, 0));
-        assert_eq!(hls_to_rgb(30, 90, 30), (87, 87, 93));
-        assert_eq!(hls_to_rgb(30, 30, 30), (21, 21, 39));
-        assert_eq!(hls_to_rgb(90, 100, 60), (100, 100, 100));
-        assert_eq!(hls_to_rgb(0, 0, 0), (0, 0, 0));
-        assert_eq!(hls_to_rgb(30, 0, 90), (0, 0, 0));
-        assert_eq!(hls_to_rgb(100, 60, 90), (96, 24, 96));
-        assert_eq!(hls_to_rgb(30, 30, 0), (30, 30, 30));
+        assert_color!(282 , 33 , 87 =>  10 , 156 , 112);
+        assert_color!( 45 , 36 , 78 => 128 ,  18 , 163);
+        assert_color!(279 ,  9 , 93 =>   0 ,  43 ,  28);
+        assert_color!(186 , 27 , 54 =>  97 , 105 ,  31);
+        assert_color!( 93 , 66 , 75 => 107 , 230 , 173);
+        assert_color!( 60 , 51 , 90 => 125 , 133 , 125);
+        assert_color!(141 , 39 , 78 => 176 ,  74 ,  20);
+        assert_color!(273 , 30 , 48 =>  38 , 112 ,  79);
+        assert_color!(270 , 15 , 57 =>  15 ,  59 ,  38);
+        assert_color!( 84 , 21 , 99 => 105 ,   0 ,  64);
+        assert_color!(162 , 81 , 93 =>  59 , 145 , 352);
+        assert_color!( 96 , 30 , 72 => 130 ,  20 ,  64);
+        assert_color!(222 , 21 , 90 =>  33 ,  99 ,   5);
+        assert_color!(306 , 33 , 39 =>  51 , 110 , 115);
+        assert_color!(144 , 30 , 72 => 130 ,  64 ,  20);
+        assert_color!( 27 ,  0 , 42 =>   0 ,   0 ,   0);
+        assert_color!(123 , 10 ,  0 =>  26 ,  26 ,  26);
+        assert_color!(279 ,  6 , 93 =>   0 ,  28 ,  18);
+        assert_color!(270 , 45 , 69 =>  33 , 194 , 115);
+        assert_color!(225 , 39 , 45 =>  77 , 143 ,  54);
     }

     #[test]

From bf743df94214c90708d008debbc66ea36c771c47 Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Fri, 15 Jul 2022 13:46:27 +0100
Subject: [PATCH 20/29] Changes in sixel module to be compatible with
 oldstable.

- Reimplement abs_diff().
- Use positional arguments to format the error message in assert_color!().
---
 alacritty_terminal/src/graphics/sixel.rs | 19 +++++++++++++++----
 1 file changed, 15 insertions(+), 4 deletions(-)

diff --git a/alacritty_terminal/src/graphics/sixel.rs b/alacritty_terminal/src/graphics/sixel.rs
index acad29c879..b3953a9370 100644
--- a/alacritty_terminal/src/graphics/sixel.rs
+++ b/alacritty_terminal/src/graphics/sixel.rs
@@ -643,16 +643,27 @@ mod tests {
         // We allow some difference between each component to ignore rounding
         // errors.

+        // Reimplement abs_diff to be compatible with rustc before 1.60.
+        fn abs_diff(x: u8, y: u8) -> u8 {
+            if x > y {
+                x - y
+            } else {
+                y - x
+            }
+        }
+
         macro_rules! assert_color {
             ($h:expr, $l:expr, $s:expr => $r:expr, $g:expr, $b:expr) => {
                 let left = hls_to_rgb($h, $l, $s);
                 let right = rgb($r, $g, $b, 255);

                 assert!(
-                    left.r.abs_diff(right.r) < 4
-                        && left.g.abs_diff(right.g) < 4
-                        && left.b.abs_diff(right.b) < 4,
-                    "Expected {right:?} Found {left:?}"
+                    abs_diff(left.r, right.r) < 4
+                        && abs_diff(left.g, right.g) < 4
+                        && abs_diff(left.b, right.b) < 4,
+                    "Expected {:?} Found {:?}",
+                    right,
+                    left,
                 );
             };
         }

From 8d2016bbef1adb2e469b1c3bb650ed891b099b98 Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Fri, 15 Jul 2022 20:35:53 +0100
Subject: [PATCH 21/29] Initialize cell dimensions when create a Graphics
 instance.

This fixes a bug that crashes the terminal when a graphic is added before
resizing the window.
---
 alacritty_terminal/src/graphics/mod.rs | 10 +++++++++-
 alacritty_terminal/src/term/mod.rs     |  4 ++--
 2 files changed, 11 insertions(+), 3 deletions(-)

diff --git a/alacritty_terminal/src/graphics/mod.rs b/alacritty_terminal/src/graphics/mod.rs
index b6f58a11b0..4641a9122c 100644
--- a/alacritty_terminal/src/graphics/mod.rs
+++ b/alacritty_terminal/src/graphics/mod.rs
@@ -296,6 +296,14 @@ pub struct Graphics {
 }

 impl Graphics {
+    /// Create a new instance, and initialize it with the dimensions of the
+    /// window.
+    pub fn new<S: Dimensions>(size: &S) -> Self {
+        let mut graphics = Graphics::default();
+        graphics.resize(size);
+        graphics
+    }
+
     /// Generate a new graphic identifier.
     pub fn next_id(&mut self) -> GraphicId {
         self.last_id += 1;
@@ -333,7 +341,7 @@ impl Graphics {
     }

     /// Update cell dimensions.
-    pub fn resize<S: Dimensions>(&mut self, size: S) {
+    pub fn resize<S: Dimensions>(&mut self, size: &S) {
         self.cell_height = size.cell_height();
         self.cell_width = size.cell_width();
     }
diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index 4fc4032b20..b02e40f4e7 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -373,7 +373,7 @@ impl<T> Term<T> {
             title: None,
             title_stack: Vec::new(),
             selection: None,
-            graphics: Graphics::default(),
+            graphics: Graphics::new(dimensions),
             damage,
         }
     }
@@ -665,7 +665,7 @@ impl<T> Term<T> {
         self.damage.resize(num_cols, num_lines);

         // Update size information for graphics.
-        self.graphics.resize(size);
+        self.graphics.resize(&size);
     }

     /// Active terminal modes.

From 03cf6302dd1e7630c177efc05c07abf645c3a0ec Mon Sep 17 00:00:00 2001
From: kumattau <kumattau@gmail.com>
Date: Wed, 5 Oct 2022 01:14:14 +0900
Subject: [PATCH 22/29] Support GLES2 Renderer in sixel

---
 alacritty/res/graphics.f.glsl             | 67 ++++++++++++++++------
 alacritty/res/graphics.v.glsl             | 70 +++++++++++++++--------
 alacritty/src/renderer/graphics/mod.rs    |  6 +-
 alacritty/src/renderer/graphics/shader.rs | 21 ++++---
 alacritty/src/renderer/mod.rs             | 21 +++----
 5 files changed, 124 insertions(+), 61 deletions(-)

diff --git a/alacritty/res/graphics.f.glsl b/alacritty/res/graphics.f.glsl
index 3423eee53a..4fa4806e78 100644
--- a/alacritty/res/graphics.f.glsl
+++ b/alacritty/res/graphics.f.glsl
@@ -1,15 +1,42 @@
+#if defined(GLES2_RENDERER) ///////////////////////////////////////////
+
+precision highp float;
+
+#define FLAT
+#define IN                      varying
+
+#define INT                     float
+
+#define SWITCH(X)               int ind = int(X);
+#define CASE(N)                 if (ind == N) {gl_FragColor = texture2D(textures[N], texCoords); return;}
+#define DEFAULT(X)              X;
+#define END_SWITCH
+
+#else // GLSL3_RENDERER ///////////////////////////////////////////////
+
+#define FLAT                    flat
+#define IN                      in
+
+#define INT                     int
+
+#define SWITCH(X)               switch(X) {
+#define CASE(N)                 case N: color = texture(textures[N], texCoords); break;
+#define DEFAULT(X)              default: X;
+#define END_SWITCH              }
+
+out vec4 color;
+
+#endif ////////////////////////////////////////////////////////////////
+
 // Index in the textures[] uniform.
-flat in int texId;
+FLAT IN INT texId;

 // Texture coordinates.
-in vec2 texCoords;
+IN vec2 texCoords;

 // Array with graphics data.
 uniform sampler2D textures[16];

-// Computed color.
-out vec4 color;
-
 void main() {
     // The expression `textures[texId]` can't be used in OpenGL 3.3.
     // If we try to use it, the compiler throws this error:
@@ -24,15 +51,23 @@ void main() {
     // or later (using `#version 400 core`). If Alacritty drops support
     // for OpenGL 3.3, this switch block can be replaced with it.

-
-#define TEX(N) case N: color = texture(textures[N], texCoords); break;
-
-    switch(texId) {
-        TEX( 0) TEX( 1) TEX( 2) TEX( 3)
-        TEX( 4) TEX( 5) TEX( 6) TEX( 7)
-        TEX( 8) TEX( 9) TEX(10) TEX(11)
-        TEX(12) TEX(13) TEX(14) TEX(15)
-        default:
-            discard;
-    }
+    SWITCH(texId)
+        CASE(0)
+        CASE(1)
+        CASE(2)
+        CASE(3)
+        CASE(4)
+        CASE(5)
+        CASE(6)
+        CASE(7)
+        CASE(8)
+        CASE(9)
+        CASE(10)
+        CASE(11)
+        CASE(12)
+        CASE(13)
+        CASE(14)
+        CASE(15)
+        DEFAULT(discard)
+    END_SWITCH
 }
diff --git a/alacritty/res/graphics.v.glsl b/alacritty/res/graphics.v.glsl
index eaeeb4edbe..31d9e49d62 100644
--- a/alacritty/res/graphics.v.glsl
+++ b/alacritty/res/graphics.v.glsl
@@ -1,44 +1,72 @@
+#if defined(GLES2_RENDERER) ///////////////////////////////////////////
+
+precision highp float;
+
+#define LAYOUT_LOCATION(N)      attribute
+#define IN
+#define FLAT
+#define OUT                     varying
+
+#define INT                     float
+
+#define IS_RIGHT_SIDE           (int(sides) == 1 || int(sides) == 3)
+#define IS_BOTTOM_SIDE          (int(sides) == 2 || int(sides) == 3)
+
+#else // GLSL3_RENDERER ///////////////////////////////////////////////
+
+#define LAYOUT_LOCATION(N)      layout(location = N)
+#define IN                      in
+#define FLAT                    flat
+#define OUT                     out
+
+#define INT                     int
+
+#define IS_RIGHT_SIDE           ((sides & 1) == 1)
+#define IS_BOTTOM_SIDE          ((sides & 2) == 2)
+
+#endif ////////////////////////////////////////////////////////////////
+
 // ------
 // INPUTS

 // Texture associated to the graphic.
-layout(location = 0) in int textureId;
+LAYOUT_LOCATION(0) IN INT textureId;

 // Sides where the vertex is located.
 //
 // Bit 0 (LSB) is 0 for top and 1 for bottom.
 // Bit 1 is 0 for left and 1 for right.
-layout(location = 1) in int sides;
+LAYOUT_LOCATION(1) IN INT sides;

 // Column number in the grid where the left vertex is set.
-layout(location = 2) in float column;
+LAYOUT_LOCATION(2) IN float column;

 // Line number in the grid where the left vertex is set.
-layout(location = 3) in float line;
+LAYOUT_LOCATION(3) IN float line;

 // Height in pixels of the texture.
-layout(location = 4) in float height;
+LAYOUT_LOCATION(4) IN float height;

 // Width in pixels of the texture.
-layout(location = 5) in float width;
+LAYOUT_LOCATION(5) IN float width;

 // Offset in the X direction.
-layout(location = 6) in float offsetX;
+LAYOUT_LOCATION(6) IN float offsetX;

 // Offset in the Y direction.
-layout(location = 7) in float offsetY;
+LAYOUT_LOCATION(7) IN float offsetY;

 // Height in pixels of a single cell when the graphic was added.
-layout(location = 8) in float baseCellHeight;
+LAYOUT_LOCATION(8) IN float baseCellHeight;

 // -------
 // OUTPUTS

 // Texture sent to the fragment shader.
-flat out int texId;
+FLAT OUT INT texId;

 // Coordinates sent to the fragment shader.
-out vec2 texCoords;
+OUT vec2 texCoords;

 // --------
 // UNIFORMS
@@ -49,26 +77,22 @@ uniform vec2 cellDimensions;
 // Width and height of the view.
 uniform vec2 viewDimensions;

-
-#define IS_RIGHT_SIDE ((sides & 1) == 1)
-#define IS_BOTTOM_SIDE ((sides & 2) == 2)
-
 void main() {
     float scale = cellDimensions.y / baseCellHeight;
-    float x = (column * cellDimensions.x - offsetX * scale) / (viewDimensions.x / 2) - 1;
-    float y = -(line * cellDimensions.y - offsetY * scale) / (viewDimensions.y / 2) + 1;
+    float x = (column * cellDimensions.x - offsetX * scale) / (viewDimensions.x / 2.) - 1.;
+    float y = -(line * cellDimensions.y - offsetY * scale) / (viewDimensions.y / 2.) + 1.;

-    vec4 position = vec4(x, y, 0, 1);
-    vec2 coords = vec2(0, 0);
+    vec4 position = vec4(x, y, 0., 1.);
+    vec2 coords = vec2(0., 0.);

     if(IS_RIGHT_SIDE) {
-        position.x += scale * width / (viewDimensions.x / 2);
-        coords.x = 1;
+        position.x += scale * width / (viewDimensions.x / 2.);
+        coords.x = 1.;
     }

     if(IS_BOTTOM_SIDE) {
-        position.y += -scale * height / (viewDimensions.y / 2);
-        coords.y = 1;
+        position.y += -scale * height / (viewDimensions.y / 2.);
+        coords.y = 1.;
     }

     gl_Position = position;
diff --git a/alacritty/src/renderer/graphics/mod.rs b/alacritty/src/renderer/graphics/mod.rs
index 5a6c59a7aa..9a22e8710b 100644
--- a/alacritty/src/renderer/graphics/mod.rs
+++ b/alacritty/src/renderer/graphics/mod.rs
@@ -3,7 +3,7 @@
 use std::mem;

 use crate::display::SizeInfo;
-use crate::renderer::RenderRect;
+use crate::renderer::{RenderRect, ShaderVersion};
 use alacritty_terminal::graphics::{
     ClearSubregion, ColorType, GraphicData, GraphicId, UpdateQueues,
 };
@@ -84,8 +84,8 @@ pub struct GraphicsRenderer {
 }

 impl GraphicsRenderer {
-    pub fn new() -> Result<GraphicsRenderer, renderer::Error> {
-        let program = shader::GraphicsShaderProgram::new()?;
+    pub fn new(shader_version: ShaderVersion) -> Result<GraphicsRenderer, renderer::Error> {
+        let program = shader::GraphicsShaderProgram::new(shader_version)?;
         let clear_texture_ext = check_opengl_extensions(&["GL_ARB_clear_texture"]);
         Ok(GraphicsRenderer { program, graphic_textures: HashMap::default(), clear_texture_ext })
     }
diff --git a/alacritty/src/renderer/graphics/shader.rs b/alacritty/src/renderer/graphics/shader.rs
index 773db44767..1aff2f3ef0 100644
--- a/alacritty/src/renderer/graphics/shader.rs
+++ b/alacritty/src/renderer/graphics/shader.rs
@@ -80,9 +80,8 @@ pub struct GraphicsShaderProgram {
 }

 impl GraphicsShaderProgram {
-    pub fn new() -> Result<Self, ShaderError> {
-        let shader =
-            ShaderProgram::new(ShaderVersion::Glsl3, GRAPHICS_SHADER_V, GRAPHICS_SHADER_F)?;
+    pub fn new(shader_version: ShaderVersion) -> Result<Self, ShaderError> {
+        let shader = ShaderProgram::new(shader_version, GRAPHICS_SHADER_V, GRAPHICS_SHADER_F)?;

         let u_cell_dimensions;
         let u_view_dimensions;
@@ -119,7 +118,7 @@ impl GraphicsShaderProgram {
             gl::UseProgram(0);
         }

-        let (vao, vbo) = define_vertex_attributes();
+        let (vao, vbo) = define_vertex_attributes(shader_version);

         let shader = Self { shader, u_cell_dimensions, u_view_dimensions, u_textures, vao, vbo };

@@ -129,7 +128,7 @@ impl GraphicsShaderProgram {

 /// Build a Vertex Array Object (VAO) and a Vertex Buffer Object (VBO) for
 /// instances of the `Vertex` type.
-fn define_vertex_attributes() -> (GLuint, GLuint) {
+fn define_vertex_attributes(shader_version: ShaderVersion) -> (GLuint, GLuint) {
     let mut vao = 0;
     let mut vbo = 0;

@@ -171,8 +170,16 @@ fn define_vertex_attributes() -> (GLuint, GLuint) {
             };
         }

-        int_attr!(UNSIGNED_INT, texture_id);
-        int_attr!(UNSIGNED_BYTE, sides);
+        match shader_version {
+            ShaderVersion::Glsl3 => {
+                int_attr!(UNSIGNED_INT, texture_id);
+                int_attr!(UNSIGNED_BYTE, sides);
+            },
+            ShaderVersion::Gles2 => {
+                float_attr!(UNSIGNED_INT, texture_id);
+                float_attr!(UNSIGNED_BYTE, sides);
+            },
+        }

         float_attr!(UNSIGNED_INT, column);
         float_attr!(UNSIGNED_INT, line);
diff --git a/alacritty/src/renderer/mod.rs b/alacritty/src/renderer/mod.rs
index 898df15d38..5f21a65bc1 100644
--- a/alacritty/src/renderer/mod.rs
+++ b/alacritty/src/renderer/mod.rs
@@ -76,7 +76,7 @@ enum TextRendererProvider {
 pub struct Renderer {
     text_renderer: TextRendererProvider,
     rect_renderer: RectRenderer,
-    graphics_renderer: Option<GraphicsRenderer>,
+    graphics_renderer: GraphicsRenderer,
 }

 impl Renderer {
@@ -96,12 +96,13 @@ impl Renderer {
         let (text_renderer, rect_renderer, graphics_renderer) = if version.as_ref() >= "3.3" {
             let text_renderer = TextRendererProvider::Glsl3(Glsl3Renderer::new()?);
             let rect_renderer = RectRenderer::new(ShaderVersion::Glsl3)?;
-            let graphics_renderer = GraphicsRenderer::new()?;
-            (text_renderer, rect_renderer, Some(graphics_renderer))
+            let graphics_renderer = GraphicsRenderer::new(ShaderVersion::Glsl3)?;
+            (text_renderer, rect_renderer, graphics_renderer)
         } else {
             let text_renderer = TextRendererProvider::Gles2(Gles2Renderer::new()?);
             let rect_renderer = RectRenderer::new(ShaderVersion::Gles2)?;
-            (text_renderer, rect_renderer, None)
+            let graphics_renderer = GraphicsRenderer::new(ShaderVersion::Gles2)?;
+            (text_renderer, rect_renderer, graphics_renderer)
         };

         Ok(Self { text_renderer, rect_renderer, graphics_renderer })
@@ -228,12 +229,10 @@ impl Renderer {
     /// Run the required actions to apply changes for the graphics in the grid.
     #[inline]
     pub fn graphics_run_updates(&mut self, update_queues: UpdateQueues, size_info: &SizeInfo) {
-        if let Some(graphics_renderer) = self.graphics_renderer.as_mut() {
-            let result = graphics_renderer.run_updates(update_queues, size_info);
+        let result = self.graphics_renderer.run_updates(update_queues, size_info);

-            if result.contains(graphics::UpdateResult::NEED_RESET_ACTIVE_TEX) {
-                self.reset_active_tex();
-            }
+        if result.contains(graphics::UpdateResult::NEED_RESET_ACTIVE_TEX) {
+            self.reset_active_tex();
         }
     }

@@ -246,9 +245,7 @@ impl Renderer {
         rects: &mut Vec<RenderRect>,
         metrics: &Metrics,
     ) {
-        if let Some(graphics_renderer) = self.graphics_renderer.as_mut() {
-            graphics_renderer.draw(render_list, size_info, rects, metrics);
-        }
+        self.graphics_renderer.draw(render_list, size_info, rects, metrics);

         self.reset_active_tex();
     }

From 396002cc0e650055e3535e7a88463650bb5ee8ee Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Sun, 16 Oct 2022 23:22:33 +0100
Subject: [PATCH 23/29] Set graphics limit per cell.

The limit per grid is increased to `1000`, and a new limit per cell is added,
set to `20`.
---
 alacritty/src/renderer/graphics/mod.rs | 2 +-
 alacritty_terminal/src/term/mod.rs     | 8 ++++++++
 2 files changed, 9 insertions(+), 1 deletion(-)

diff --git a/alacritty/src/renderer/graphics/mod.rs b/alacritty/src/renderer/graphics/mod.rs
index 9a22e8710b..a6b601b280 100644
--- a/alacritty/src/renderer/graphics/mod.rs
+++ b/alacritty/src/renderer/graphics/mod.rs
@@ -23,7 +23,7 @@ mod draw;
 mod shader;

 /// Max. number of textures stored in the GPU.
-const MAX_TEXTURES_COUNT: usize = 100;
+const MAX_TEXTURES_COUNT: usize = 1000;

 pub use draw::RenderList;

diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index d54d9998f4..a35fade2cf 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -44,6 +44,9 @@ const TITLE_STACK_MAX_DEPTH: usize = 4096;
 /// Default tab interval, corresponding to terminfo `it` value.
 const INITIAL_TABSTOPS: usize = 8;

+/// Max. number of graphics stored in a single cell.
+const MAX_GRAPHICS_PER_CELL: usize = 20;
+
 bitflags! {
     pub struct TermMode: u32 {
         const NONE                = 0;
@@ -2159,6 +2162,11 @@ impl<T: EventListener> Handler for Term<T> {
                                 cell_height as usize,
                             ) =>
                     {
+                        // Ensure that we don't exceed the graphics limit per cell.
+                        while old_graphics.len() >= MAX_GRAPHICS_PER_CELL {
+                            drop(old_graphics.remove(0));
+                        }
+
                         old_graphics.push(graphic_cell);
                         old_graphics
                     },

From a9335fcb11d1fd9fd4d5c31468e27e0a531fd140 Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Sun, 16 Oct 2022 23:25:19 +0100
Subject: [PATCH 24/29] Add Eq derive to ClearSubregion.

Suggested by clippy.
---
 alacritty_terminal/src/graphics/mod.rs | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/alacritty_terminal/src/graphics/mod.rs b/alacritty_terminal/src/graphics/mod.rs
index 4641a9122c..6f43f4e6ee 100644
--- a/alacritty_terminal/src/graphics/mod.rs
+++ b/alacritty_terminal/src/graphics/mod.rs
@@ -238,7 +238,7 @@ impl GraphicData {
 }

 /// Operation to clear a subregion in an existing graphic.
-#[derive(Serialize, Deserialize, PartialEq, Clone, Debug)]
+#[derive(Serialize, Deserialize, Eq, PartialEq, Clone, Debug)]
 pub struct ClearSubregion {
     /// Graphics identifier.
     pub id: GraphicId,

From 615e72ed9763a695737419ff93e81574d30fd41c Mon Sep 17 00:00:00 2001
From: kumattau <kumattau@gmail.com>
Date: Fri, 21 Oct 2022 03:09:54 +0900
Subject: [PATCH 25/29] CSI XTSMGRAPHICS Pi=2, Pa=1 should return dimensions
 that fit in text area

---
 alacritty_terminal/src/term/mod.rs | 83 ++++++++++++++++++++++++------
 1 file changed, 66 insertions(+), 17 deletions(-)

diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index a35fade2cf..8461d25603 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -1998,32 +1998,81 @@ impl<T: EventListener> Handler for Term<T> {
     fn graphics_attribute(&mut self, pi: u16, pa: u16) {
         // From Xterm documentation:
         //
+        //   CSI ? Pi ; Pa ; Pv S
+        //
         //   Pi = 1  -> item is number of color registers.
         //   Pi = 2  -> item is Sixel graphics geometry (in pixels).
+        //   Pi = 3  -> item is ReGIS graphics geometry (in pixels).
         //
         //   Pa = 1  -> read attribute.
+        //   Pa = 2  -> reset to default.
+        //   Pa = 3  -> set to value in Pv.
         //   Pa = 4  -> read the maximum allowed value.
         //
-        // Any other request reports an error.
+        //   Pv is ignored by xterm except when setting (Pa == 3).
+        //   Pv = n <- A single integer is used for color registers.
+        //   Pv = width ; height <- Two integers for graphics geometry.
+        //
+        //   xterm replies with a control sequence of the same form:
+        //
+        //   CSI ? Pi ; Ps ; Pv S
+        //
+        //   where Ps is the status:
+        //   Ps = 0  <- success.
+        //   Ps = 1  <- error in Pi.
+        //   Ps = 2  <- error in Pa.
+        //   Ps = 3  <- failure.
+        //
+        //   On success, Pv represents the value read or set.

-        let (ps, pv) = if pa == 1 || pa == 4 {
-            match pi {
-                1 => (0, &[sixel::MAX_COLOR_REGISTERS][..]),
-                2 => (0, &MAX_GRAPHIC_DIMENSIONS[..]),
-                _ => (1, &[][..]), // Report error in Pi
+        fn generate_response(pi: u16, ps: u16, pv: &[usize]) -> String {
+            let mut text = format!("\x1b[?{};{}", pi, ps);
+            for item in pv {
+                let _ = write!(&mut text, ";{}", item);
+            }
+            text.push('S');
+            text
+        }
+
+        let (ps, pv) = match pi {
+            1 => {
+                match pa {
+                    1 => (0, &[sixel::MAX_COLOR_REGISTERS][..]), // current value is always the maximum
+                    2 => (3, &[][..]), // Report unsupported
+                    3 => (3, &[][..]), // Report unsupported
+                    4 => (0, &[sixel::MAX_COLOR_REGISTERS][..]),
+                    _ => (2, &[][..]), // Report error in Pa
+                }
+            }
+            2 => {
+                match pa {
+                    1 => {
+                        self.event_proxy.send_event(Event::TextAreaSizeRequest(Arc::new(move |window_size| {
+                            let width = window_size.num_cols * window_size.cell_width;
+                            let height = window_size.num_lines * window_size.cell_height;
+                            let graphic_dimensions = [
+                                cmp::min(width as usize, MAX_GRAPHIC_DIMENSIONS[0]),
+                                cmp::min(height as usize, MAX_GRAPHIC_DIMENSIONS[1])];
+
+                            let (ps, pv) = (0, &graphic_dimensions[..]);
+                            generate_response(pi, ps, pv)
+                        })));
+                        return;
+                    }
+                    2 => (3, &[][..]), // Report unsupported
+                    3 => (3, &[][..]), // Report unsupported
+                    4 => (0, &MAX_GRAPHIC_DIMENSIONS[..]),
+                    _ => (2, &[][..]), // Report error in Pa
+                }
+            }
+            3 => {
+                (1, &[][..]) // Report error in Pi (ReGIS unknown)
+            }
+            _ => {
+                (1, &[][..]) // Report error in Pi
             }
-        } else {
-            (2, &[][..]) // Report error in Pa
         };
-
-        let mut text = format!("\x1b[?{};{}", pi, ps);
-
-        for item in pv {
-            let _ = write!(&mut text, ";{}", item);
-        }
-
-        text.push('S');
-        self.event_proxy.send_event(Event::PtyWrite(text));
+        self.event_proxy.send_event(Event::PtyWrite(generate_response(pi, ps, pv)));
     }

     fn start_sixel_graphic(&mut self, params: &Params) -> Option<Box<sixel::Parser>> {

From 2f3a8cf443b234e2a86212ae4e238b48e7e1a32b Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Thu, 20 Oct 2022 22:24:12 +0100
Subject: [PATCH 26/29] Remove entry about Sixel support in the changelog.

---
 CHANGELOG.md | 1 -
 1 file changed, 1 deletion(-)

diff --git a/CHANGELOG.md b/CHANGELOG.md
index 746b013a0e..03a8c9ba73 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -21,7 +21,6 @@ The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).

 ### Added

-- Support for Sixel protocol
 - Track and report surface damage information to Wayland compositors
 - Escape sequence for undercurl, dotted and dashed underlines (`CSI 4 : [3-5] m`)
 - `ToggleMaximized` key binding action to (un-)maximize the active window, not bound by default

From ed6e3fa3dfec1ce59eb0ed9ed0ed3bfc4f4b1da6 Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Thu, 20 Oct 2022 22:33:31 +0100
Subject: [PATCH 27/29] Update damage when a graphics is inserted.

---
 alacritty_terminal/src/term/mod.rs | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index 8461d25603..046d08cf72 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -2225,6 +2225,8 @@ impl<T: EventListener> Handler for Term<T> {

                 cell.set_graphics(graphics);
                 *cell_ref = cell;
+
+                self.damage.damage_point(Point::new(line.0 as usize, Column(left)));
             }

             if scrolling && offset_y < height.saturating_sub(cell_height as u16) {

From 48a388ad91d268ed97355df629a22e2d476aee2a Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Thu, 20 Oct 2022 22:35:36 +0100
Subject: [PATCH 28/29] Apply rustfmt to term/mod.rs.

---
 alacritty_terminal/src/term/mod.rs | 40 ++++++++++++++++++------------
 1 file changed, 24 insertions(+), 16 deletions(-)

diff --git a/alacritty_terminal/src/term/mod.rs b/alacritty_terminal/src/term/mod.rs
index 046d08cf72..e814d30b55 100644
--- a/alacritty_terminal/src/term/mod.rs
+++ b/alacritty_terminal/src/term/mod.rs
@@ -2037,41 +2037,49 @@ impl<T: EventListener> Handler for Term<T> {
         let (ps, pv) = match pi {
             1 => {
                 match pa {
-                    1 => (0, &[sixel::MAX_COLOR_REGISTERS][..]), // current value is always the maximum
+                    1 => (0, &[sixel::MAX_COLOR_REGISTERS][..]), // current value is always the
+                    // maximum
                     2 => (3, &[][..]), // Report unsupported
                     3 => (3, &[][..]), // Report unsupported
                     4 => (0, &[sixel::MAX_COLOR_REGISTERS][..]),
                     _ => (2, &[][..]), // Report error in Pa
                 }
-            }
+            },
+
             2 => {
                 match pa {
                     1 => {
-                        self.event_proxy.send_event(Event::TextAreaSizeRequest(Arc::new(move |window_size| {
-                            let width = window_size.num_cols * window_size.cell_width;
-                            let height = window_size.num_lines * window_size.cell_height;
-                            let graphic_dimensions = [
-                                cmp::min(width as usize, MAX_GRAPHIC_DIMENSIONS[0]),
-                                cmp::min(height as usize, MAX_GRAPHIC_DIMENSIONS[1])];
-
-                            let (ps, pv) = (0, &graphic_dimensions[..]);
-                            generate_response(pi, ps, pv)
-                        })));
+                        self.event_proxy.send_event(Event::TextAreaSizeRequest(Arc::new(
+                            move |window_size| {
+                                let width = window_size.num_cols * window_size.cell_width;
+                                let height = window_size.num_lines * window_size.cell_height;
+                                let graphic_dimensions = [
+                                    cmp::min(width as usize, MAX_GRAPHIC_DIMENSIONS[0]),
+                                    cmp::min(height as usize, MAX_GRAPHIC_DIMENSIONS[1]),
+                                ];
+
+                                let (ps, pv) = (0, &graphic_dimensions[..]);
+                                generate_response(pi, ps, pv)
+                            },
+                        )));
                         return;
-                    }
+                    },
                     2 => (3, &[][..]), // Report unsupported
                     3 => (3, &[][..]), // Report unsupported
                     4 => (0, &MAX_GRAPHIC_DIMENSIONS[..]),
                     _ => (2, &[][..]), // Report error in Pa
                 }
-            }
+            },
+
             3 => {
                 (1, &[][..]) // Report error in Pi (ReGIS unknown)
-            }
+            },
+
             _ => {
                 (1, &[][..]) // Report error in Pi
-            }
+            },
         };
+
         self.event_proxy.send_event(Event::PtyWrite(generate_response(pi, ps, pv)));
     }


From fc97c07516658f0a10970189d65e2766fb1071c3 Mon Sep 17 00:00:00 2001
From: Ayose <ayosec@gmail.com>
Date: Fri, 2 Dec 2022 00:58:10 +0000
Subject: [PATCH 29/29] Apply rustfmt and clippy to the current branch.

---
 alacritty/src/renderer/graphics/shader.rs | 5 +++--
 1 file changed, 3 insertions(+), 2 deletions(-)

diff --git a/alacritty/src/renderer/graphics/shader.rs b/alacritty/src/renderer/graphics/shader.rs
index 0fcac43f14..e046c9aead 100644
--- a/alacritty/src/renderer/graphics/shader.rs
+++ b/alacritty/src/renderer/graphics/shader.rs
@@ -13,7 +13,7 @@ pub(super) const TEXTURES_ARRAY_SIZE: usize = 16;
 ///
 /// * Bit 0 (LSB) is 0 for top and 1 for bottom.
 /// * Bit 1 is 0 for left and 1 for right.
-#[derive(Debug, Copy, Clone, PartialEq)]
+#[derive(Debug, Copy, Clone, PartialEq, Eq)]
 #[repr(u8)]
 pub enum VertexSide {
     TopLeft = 0b00,
@@ -81,7 +81,8 @@ pub struct GraphicsShaderProgram {

 impl GraphicsShaderProgram {
     pub fn new(shader_version: ShaderVersion) -> Result<Self, ShaderError> {
-        let shader = ShaderProgram::new(shader_version, None, GRAPHICS_SHADER_V, GRAPHICS_SHADER_F)?;
+        let shader =
+            ShaderProgram::new(shader_version, None, GRAPHICS_SHADER_V, GRAPHICS_SHADER_F)?;

         let u_cell_dimensions;
         let u_view_dimensions;

